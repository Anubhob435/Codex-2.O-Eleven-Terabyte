import os
import sqlite3
import hashlib
import pandas as pd
import streamlit as st
from streamlit_option_menu import option_menu
import pickle
import datetime
from fpdf import FPDF
import requests
import numpy as np
import bcrypt # Added for the second encryption layer
import pyotp # Added for MFA
import qrcode # Added for MFA QR code generation

# --- FEDERATED LEARNING SERVER CONFIGURATION ---
# IMPORTANT: Replace "192.168.31.202" with the actual IP address of the PC running your server.py
# Make sure your server's firewall allows incoming connections on port 5000 (Flask) and 8080/8081/8082 (Flower gRPC).\
FL_SERVER_URL = "http://127.0.0.1:5000" # Base URL for Flask server

# Diabetes Model Specific Paths
CLIENT_DIABETES_DATA_DIR = "client_diabetes_data" # Directory to store client-specific diabetes data
os.makedirs(CLIENT_DIABETES_DATA_DIR, exist_ok=True)

# Heart Model Specific Paths
CLIENT_HEART_DATA_DIR = "client_heart_data" # Directory to store client-specific heart data
os.makedirs(CLIENT_HEART_DATA_DIR, exist_ok=True)

# Parkinson's Model Specific Paths
CLIENT_PARKINSONS_DATA_DIR = "client_parkinsons_data" # Directory to store client-specific parkinsons data
os.makedirs(CLIENT_PARKINSONS_DATA_DIR, exist_ok=True)

# --- QR Code Placeholder for Online Payments ---
# In a real application, this URL would be dynamically generated by a payment gateway
# based on the specific transaction details (e.g., amount, patient ID, etc.).
QR_CODE_PLACEHOLDER_URL = "https://kinsta.com/wp-content/uploads/2019/03/kinsta-qr-code.png"


# Set page configuration
st.set_page_config(page_title="ChainLearn Nexus", layout="wide", page_icon="üßë‚Äç‚öïÔ∏è")

# Connect to SQLite database
# Use check_same_thread=False for Streamlit as it can run threads in unexpected ways
conn = sqlite3.connect('healthcare.db', check_same_thread=False)
cursor = conn.cursor()

def init_db():
    """Initializes the SQLite database tables if they don't exist."""
    cursor.execute('''CREATE TABLE IF NOT EXISTS doctors (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        doctor_id TEXT UNIQUE,
                        name TEXT,
                        specialization TEXT,
                        qualifications TEXT,
                        experience INTEGER,
                        location TEXT,
                        phone TEXT,
                        email TEXT,
                        chambers TEXT,
                        rating INTEGER)''')
    cursor.execute('''CREATE TABLE IF NOT EXISTS appointments (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        patient_id TEXT UNIQUE,
                        patient_name TEXT,
                        doctor_id TEXT,
                        appointment_date TEXT,
                        appointment_time TEXT,
                        reason TEXT,
                        phone TEXT,
                        email TEXT,
                        location TEXT,
                        status TEXT,
                        payment_details TEXT,
                        mode TEXT,
                        instructions TEXT)''')
    # Create necessary tables for user authentication and test results
    # Modified users1 table to include bcrypt_hash AND mfa_secret
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS users1 (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT UNIQUE,
        name TEXT,
        role TEXT,
        password TEXT, -- Stores SHA256 hash
        salt TEXT,      -- Stores SHA256 salt for password
        bcrypt_hash BLOB, -- Stores bcrypt hash of the SHA256 hash for password
        mfa_secret TEXT DEFAULT NULL -- Added for MFA secret
    )
    ''')
    # Modified test_results1 table to store hashed data
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS test_results1 (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id_hash TEXT,      -- Hashed user_id
        user_id_salt TEXT,      -- Salt for user_id hash
        name_hash TEXT,         -- Hashed name
        name_salt TEXT,         -- Salt for name hash
        date_hash TEXT,         -- Hashed date
        date_salt TEXT,         -- Salt for date hash
        time_hash TEXT,         -- Hashed time
        time_salt TEXT,         -- Salt for time hash
        disease_hash TEXT,      -- Hashed disease
        disease_salt TEXT,      -- Salt for disease hash
        result_hash TEXT,       -- Hashed result
        result_salt TEXT,       -- Salt for result hash
        combined_bcrypt_hash BLOB -- Bcrypt hash of all combined SHA256 hashes for record integrity
    )
    ''')
    conn.commit()

# Initialize the database when the script starts
init_db()

# Password Hashing with SHA-256 and bcrypt (for user login)
def hash_password(password):
    """Hashes a password with SHA-256 and then bcrypt."""
    # First, SHA-256 hash
    sha256_salt = os.urandom(32) # Generate a new salt for SHA-256
    sha256_hashed_password = hashlib.sha256(sha256_salt + password.encode()).hexdigest()

    # Second, bcrypt hash the SHA256 output
    # bcrypt generates its own salt internally
    # We need to encode the SHA256 hash to bytes for bcrypt
    bcrypt_hashed_password = bcrypt.hashpw(sha256_hashed_password.encode('utf-8'), bcrypt.gensalt())
    
    # Store sha256_salt as hex string, sha256_hashed_password as hex string, and bcrypt_hashed_password as bytes
    return sha256_hashed_password, sha256_salt.hex(), bcrypt_hashed_password

def verify_password(stored_sha256_hash, stored_sha256_salt_hex, stored_bcrypt_hash, input_password):
    """Verifies an input password against stored SHA-256 and bcrypt hashes."""
    # Convert stored_sha256_salt_hex back to bytes
    stored_sha256_salt = bytes.fromhex(stored_sha256_salt_hex)

    # First, re-hash the input password with the stored SHA-256 salt
    input_sha256_hash = hashlib.sha256(stored_sha256_salt + input_password.encode()).hexdigest()

    # Compare the SHA-256 hashes (optional, but good for early exit if SHA256 mismatch)
    if stored_sha256_hash != input_sha256_hash:
        return False

    # Second, verify the SHA-256 hash of the input password against the stored bcrypt hash
    # bcrypt.checkpw expects the first argument to be the password (as bytes) and the second to be the bcrypt hash (as bytes).
    return bcrypt.checkpw(input_sha256_hash.encode('utf-8'), stored_bcrypt_hash)


# Hashing function for individual test result data fields
def hash_data_field(data_string):
    """Hashes a single string data field using SHA-256."""
    data_salt = os.urandom(16) # Smaller salt for data fields, if needed
    hashed_data = hashlib.sha256(data_salt + data_string.encode()).hexdigest()
    return hashed_data, data_salt.hex()

# Combined hashing for integrity check of a full record
def hash_record_integrity(hashed_fields_list):
    """
    Computes a bcrypt hash of a concatenated string of SHA256 hashed fields
    for overall record integrity. This is not for individual field retrieval.
    """
    combined_sha256_string = "".join(hashed_fields_list)
    return bcrypt.hashpw(combined_sha256_string.encode('utf-8'), bcrypt.gensalt())

# --- MFA Specific Functions ---
def generate_qr_code(secret, user_id, issuer_name="ChainLearn Nexus"):
    """
    Generates a QR code for MFA setup using the provided secret and user ID.
    The QR code contains the TOTP provisioning URI.
    """
    totp_uri = pyotp.totp.TOTP(secret).provisioning_uri(name=user_id, issuer_name=issuer_name)
    qr_code_path = f"./qr_codes/mfa_qr_{user_id}.png"
    os.makedirs(os.path.dirname(qr_code_path), exist_ok=True)
    img = qrcode.make(totp_uri)
    img.save(qr_code_path)
    return qr_code_path

# Session State Initialization
if "logged_in" not in st.session_state:
    st.session_state["logged_in"] = False
    st.session_state["user_id"] = None
    st.session_state["role"] = None
    st.session_state["name"] = None # Added for convenience
    st.session_state["show_mfa_qr"] = False # New: Control QR code display
    st.session_state["current_mfa_secret"] = None # New: Store MFA secret temporarily
    st.session_state["current_user_id_for_mfa"] = None # New: Store user ID for MFA setup

# NEW: Ensure prediction result session states are initialized always
if "diab_prediction_result" not in st.session_state:
    st.session_state["diab_prediction_result"] = None
if "heart_prediction_result" not in st.session_state:
    st.session_state["heart_prediction_result"] = None
if "parkinsons_prediction_result" not in st.session_state:
    st.session_state["parkinsons_prediction_result"] = None

# Initialize session state for prediction inputs to allow pre-filling
if "diab_pregnancies" not in st.session_state:
    st.session_state["diab_pregnancies"] = ""
    st.session_state["diab_glucose"] = ""
    st.session_state["diab_bp"] = ""
    st.session_state["diab_skin_thickness"] = ""
    st.session_state["diab_insulin"] = ""
    st.session_state["diab_bmi"] = ""
    st.session_state["diab_dpf"] = ""
    st.session_state["diab_age"] = ""

if "heart_age" not in st.session_state:
    st.session_state["heart_age"] = ""
    st.session_state["heart_sex"] = ""
    st.session_state["heart_cp"] = ""
    st.session_state["heart_trestbps"] = ""
    st.session_state["heart_chol"] = ""
    st.session_state["heart_fbs"] = ""
    st.session_state["heart_restecg"] = ""
    st.session_state["heart_thalach"] = ""
    st.session_state["heart_exang"] = ""
    st.session_state["heart_oldpeak"] = ""
    st.session_state["heart_slope"] = ""
    st.session_state["heart_ca"] = ""
    st.session_state["heart_thal"] = ""

if "park_fo" not in st.session_state:
    st.session_state["park_fo"] = ""
    st.session_state["park_fhi"] = ""
    st.session_state["park_flo"] = ""
    st.session_state["park_jitter_percent"] = ""
    st.session_state["park_jitter_abs"] = ""
    st.session_state["park_rap"] = ""
    st.session_state["park_ppq"] = ""
    st.session_state["park_ddp"] = ""
    st.session_state["park_shimmer"] = ""
    st.session_state["park_shimmer_db"] = ""
    st.session_state["park_apq3"] = ""
    st.session_state["park_apq5"] = ""
    st.session_state["park_apq"] = ""
    st.session_state["park_dda"] = ""
    st.session_state["park_nhr"] = ""
    st.session_state["park_hnr"] = ""
    st.session_state["park_rpde"] = ""
    st.session_state["park_dfa"] = ""
    st.session_state["park_spread1"] = ""
    st.session_state["park_spread2"] = ""
    st.session_state["park_d2"] = ""
    st.session_state["park_ppe"] = ""


# --- NEW: Function to download model from FL Server ---
@st.cache_resource(ttl=3600) # Cache the model for 1 hour to reduce server load
def get_global_model(model_type="diabetes"):
    """
    Fetches the latest global model from the federated learning server based on model_type.
    """
    if model_type == "diabetes":
        endpoint = "/get_diabetes_model"
        model_file_name = "global_diabetes_model.pkl"
        client_data_dir = CLIENT_DIABETES_DATA_DIR
    elif model_type == "heart":
        endpoint = "/get_heart_model"
        model_file_name = "global_heart_model.pkl"
        client_data_dir = CLIENT_HEART_DATA_DIR
    elif model_type == "parkinsons": # NEW: Parkinson's model
        endpoint = "/get_parkinsons_model"
        model_file_name = "global_parkinsons_model.pkl"
        client_data_dir = CLIENT_PARKINSONS_DATA_DIR
    else:
        st.error(f"Unknown model type: {model_type}")
        return None

    st.info(f"Attempting to download latest '{model_type}' model from FL server at {FL_SERVER_URL}{endpoint}...")
    try:
        response = requests.get(f"{FL_SERVER_URL}{endpoint}", stream=True, timeout=30) # Increased timeout
        response.raise_for_status() # Raise an exception for HTTP errors (4xx or 5xx)
        
        # Save the model to a temporary local file
        temp_model_path = os.path.join(client_data_dir, model_file_name)
        with open(temp_model_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        
        # Load the model from the temporary file
        with open(temp_model_path, 'rb') as f:
            model = pickle.load(f)
        st.success(f"Successfully downloaded latest {model_type} model from server.")
        return model
    except requests.exceptions.ConnectionError:
        st.error(f"Could not connect to the Federated Learning Server at {FL_SERVER_URL}. Please ensure it's running and accessible.")
        return None
    except requests.exceptions.Timeout:
        st.error(f"Connection to Federated Learning Server timed out after 30 seconds. Server might be busy or unreachable.")
        return None
    except requests.exceptions.HTTPError as e:
        st.error(f"HTTP Error fetching {model_type} model from server: {e}. Response: {e.text}")
        return None
    except Exception as e:
        st.error(f"An unexpected error occurred while loading the {model_type} model: {e}")
        return None

# --- Function to append client data to local CSV for Diabetes ---
def append_client_diabetes_data(data_dict, user_id):
    """
    Appends new prediction input data and result to a client-specific CSV for Diabetes.
    This data is stored on the client's local machine before being sent to the FL server.
    """
    client_csv_path = os.path.join(CLIENT_DIABETES_DATA_DIR, f"client_diabetes_data_{user_id}.csv")
    
    # Create a DataFrame from the new data dictionary
    df_new = pd.DataFrame([data_dict])
    
    if not os.path.exists(client_csv_path) or pd.read_csv(client_csv_path).empty:
        # If file doesn't exist or is empty, just save the new data
        df_new.to_csv(client_csv_path, mode='w', index=False) # 'w' to create/overwrite if empty
    else:
        # If file exists and has content, load it and concatenate
        df_existing = pd.read_csv(client_csv_path)
        
        # Ensure consistent columns before concatenation
        all_columns = list(set(df_existing.columns).union(df_new.columns))
        df_existing = df_existing.reindex(columns=all_columns, fill_value=0)
        df_new = df_new.reindex(columns=all_columns, fill_value=0)
        
        updated_df = pd.concat([df_existing, df_new], ignore_index=True)
        updated_df.to_csv(client_csv_path, mode='w', index=False)
    st.info(f"Prediction data saved locally for Diabetes client {user_id} at {client_csv_path}.")

# --- Function to append client data to local CSV for Heart Disease ---
def append_client_heart_data(data_dict, user_id):
    """
    Appends new prediction input data and result to a client-specific CSV for Heart Disease.
    This data is stored on the client's local machine before being sent to the FL server.
    """
    client_csv_path = os.path.join(CLIENT_HEART_DATA_DIR, f"client_heart_data_{user_id}.csv")
    
    # Create a DataFrame from the new data dictionary
    df_new = pd.DataFrame([data_dict])
    
    if not os.path.exists(client_csv_path) or pd.read_csv(client_csv_path).empty:
        # If file doesn't exist or is empty, just save the new data
        df_new.to_csv(client_csv_path, mode='w', index=False) # 'w' to create/overwrite if empty
    else:
        # If file exists and has content, load it and concatenate
        df_existing = pd.read_csv(client_csv_path)
        
        # Ensure consistent columns before concatenation
        all_columns = list(set(df_existing.columns).union(df_new.columns))
        df_existing = df_existing.reindex(columns=all_columns, fill_value=0)
        df_new = df_new.reindex(columns=all_columns, fill_value=0)
        
        updated_df = pd.concat([df_existing, df_new], ignore_index=True)
        updated_df.to_csv(client_csv_path, mode='w', index=False)
    st.info(f"Prediction data saved locally for Heart Disease client {user_id} at {client_csv_path}.")

# --- NEW: Function to append client data to local CSV for Parkinson's ---
def append_client_parkinsons_data(data_dict, user_id):
    """
    Appends new prediction input data and result to a client-specific CSV for Parkinson's.
    This data is stored on the client's local machine before being sent to the FL server.
    """
    client_csv_path = os.path.join(CLIENT_PARKINSONS_DATA_DIR, f"client_parkinsons_data_{user_id}.csv")
    
    # Create a DataFrame from the new data dictionary
    df_new = pd.DataFrame([data_dict])
    
    if not os.path.exists(client_csv_path) or pd.read_csv(client_csv_path).empty:
        # If file doesn't exist or is empty, just save the new data
        df_new.to_csv(client_csv_path, mode='w', index=False) # 'w' to create/overwrite if empty
    else:
        # If file exists and has content, load it and concatenate
        df_existing = pd.read_csv(client_csv_path)
        
        # Ensure consistent columns before concatenation
        all_columns = list(set(df_existing.columns).union(df_new.columns))
        df_existing = df_existing.reindex(columns=all_columns, fill_value=0)
        df_new = df_new.reindex(columns=all_columns, fill_value=0)
        
        updated_df = pd.concat([df_existing, df_new], ignore_index=True)
        updated_df.to_csv(client_csv_path, mode='w', index=False)
    st.info(f"Prediction data saved locally for Parkinson's client {user_id} at {client_csv_path}.")


# --- Function to send client data to FL Server for Diabetes ---
def send_diabetes_client_data_to_server(user_id):
    """
    Reads all new data from the client's local Diabetes CSV and sends it to the FL server.
    Then clears the local CSV.
    """
    client_csv_path = os.path.join(CLIENT_DIABETES_DATA_DIR, f"client_diabetes_data_{user_id}.csv")
    
    if not os.path.exists(client_csv_path) or os.stat(client_csv_path).st_size == 0:
        st.warning("No new local Diabetes data to send to the server.")
        return False

    try:
        df_to_send = pd.read_csv(client_csv_path)
        
        # Convert DataFrame to list of dictionaries for JSON payload
        records_to_send = df_to_send.to_dict(orient='records')
        
        st.info(f"Sending {len(records_to_send)} diabetes records from client {user_id} to FL server...")
        payload = {
            "client_id": user_id,
            "records": records_to_send
        }
        
        response = requests.post(f"{FL_SERVER_URL}/upload_diabetes_client_data", json=payload, timeout=60) # Increased timeout for large uploads
        response.raise_for_status() # Raise an exception for HTTP errors (4xx or 5xx)
        
        if response.json().get('status') == 'success':
            st.success("Successfully uploaded Diabetes client data to Federated Learning Server!")
            # Clear the local CSV after successful upload by overwriting with an empty DataFrame
            pd.DataFrame(columns=df_to_send.columns).to_csv(client_csv_path, index=False)
            st.info("Local Diabetes client data cleared after upload.")
            return True
        else:
            st.error(f"Failed to upload Diabetes data. Server responded: {response.json().get('message', 'Unknown error')}. Full response: {response.text}")
            return False
    except requests.exceptions.ConnectionError:
        st.error(f"Could not connect to the Federated Learning Server at {FL_SERVER_URL}. Please ensure it's running and accessible. Diabetes Data not uploaded.")
        return False
    except requests.exceptions.Timeout:
        st.error(f"Connection to Federated Learning Server timed out after 60 seconds. Server might be busy or unreachable.")
        return False
    except requests.exceptions.HTTPError as e:
        st.error(f"HTTP Error fetching Diabetes model from server: {e}. Response: {e.text}. Diabetes Data not uploaded.")
        return False
    except Exception as e:
        st.error(f"An unexpected error occurred during Diabetes data upload: {e}")
        return False

# --- Function to send client data to FL Server for Heart Disease ---
def send_heart_client_data_to_server(user_id):
    """
    Reads all new data from the client's local Heart Disease CSV and sends it to the FL server.
    Then clears the local CSV.
    """
    client_csv_path = os.path.join(CLIENT_HEART_DATA_DIR, f"client_heart_data_{user_id}.csv")
    
    if not os.path.exists(client_csv_path) or os.stat(client_csv_path).st_size == 0:
        st.warning("No new local Heart Disease data to send to the server.")
        return False

    try:
        df_to_send = pd.read_csv(client_csv_path)
        
        # Convert DataFrame to list of dictionaries for JSON payload
        records_to_send = df_to_send.to_dict(orient='records')
        
        st.info(f"Sending {len(records_to_send)} heart disease records from client {user_id} to FL server...")
        payload = {
            "client_id": user_id,
            "records": records_to_send
        }
        
        response = requests.post(f"{FL_SERVER_URL}/upload_heart_client_data", json=payload, timeout=60) # Increased timeout for large uploads
        response.raise_for_status() # Raise an exception for HTTP errors (4xx or 5xx)
        
        if response.json().get('status') == 'success':
            st.success("Successfully uploaded Heart Disease client data to Federated Learning Server!")
            # Clear the local CSV after successful upload by overwriting with an empty DataFrame
            pd.DataFrame(columns=df_to_send.columns).to_csv(client_csv_path, index=False)
            st.info("Local Heart Disease client data cleared after upload.")
            return True
        else:
            st.error(f"Failed to upload Heart Disease data. Server responded: {response.json().get('message', 'Unknown error')}. Full response: {response.text}")
            return False
    except requests.exceptions.ConnectionError:
        st.error(f"Could not connect to the Federated Learning Server at {FL_SERVER_URL}. Please ensure it's running and accessible. Heart Disease Data not uploaded.")
        return False
    except requests.exceptions.Timeout:
        st.error(f"Connection to Federated Learning Server timed out after 60 seconds. Server might be busy or unreachable.")
        return False
    except requests.exceptions.HTTPError as e:
        st.error(f"HTTP Error fetching Heart Disease model from server: {e}. Response: {e.text}. Heart Disease Data not uploaded.")
        return False
    except Exception as e:
        st.error(f"An unexpected error occurred during Heart Disease data upload: {e}")
        return False

# --- NEW: Function to send client data to FL Server for Parkinson's ---
def send_parkinsons_client_data_to_server(user_id):
    """
    Reads all new data from the client's local Parkinson's CSV and sends it to the FL server.
    Then clears the local CSV.
    """
    client_csv_path = os.path.join(CLIENT_PARKINSONS_DATA_DIR, f"client_parkinsons_data_{user_id}.csv")
    
    if not os.path.exists(client_csv_path) or os.stat(client_csv_path).st_size == 0:
        st.warning("No new local Parkinson's data to send to the server.")
        return False

    try:
        df_to_send = pd.read_csv(client_csv_path)
        
        # Convert DataFrame to list of dictionaries for JSON payload
        records_to_send = df_to_send.to_dict(orient='records')
        
        st.info(f"Sending {len(records_to_send)} Parkinson's records from client {user_id} to FL server...")
        payload = {
            "client_id": user_id,
            "records": records_to_send
        }
        
        response = requests.post(f"{FL_SERVER_URL}/upload_parkinsons_client_data", json=payload, timeout=60) # Increased timeout for large uploads
        response.raise_for_status() # Raise an exception for HTTP errors (4xx or 5xx)
        
        if response.json().get('status') == 'success':
            st.success("Successfully uploaded Parkinson's client data to Federated Learning Server!")
            # Clear the local CSV after successful upload by overwriting with an empty DataFrame
            pd.DataFrame(columns=df_to_send.columns).to_csv(client_csv_path, index=False)
            st.info("Local Parkinson's client data cleared after upload.")
            return True
        else:
            st.error(f"Failed to upload Parkinson's data. Server responded: {response.json().get('message', 'Unknown error')}. Full response: {response.text}")
            return False
    except requests.exceptions.ConnectionError:
        st.error(f"Could not connect to the Federated Learning Server at {FL_SERVER_URL}. Please ensure it's running and accessible. Parkinson's Data not uploaded.")
        return False
    except requests.exceptions.Timeout:
        st.error(f"Connection to Federated Learning Server timed out after 60 seconds. Server might be busy or unreachable.")
        return False
    except requests.exceptions.HTTPError as e:
        st.error(f"HTTP Error fetching Parkinson's model from server: {e}. Response: {e.text}. Parkinson's Data not uploaded.")
        return False
    except Exception as e:
        st.error(f"An unexpected error occurred during Parkinson's data upload: {e}")
        return False


# --- Authentication Logic ---
if not st.session_state["logged_in"]:
    # New: Conditional display for MFA QR after successful registration
    if st.session_state.get("show_mfa_qr"):
        st.title("Setup Multi-Factor Authentication")
        st.info(f"Please scan the QR code below with your authenticator app (e.g., Google Authenticator, Authy). Your User ID is **{st.session_state['current_user_id_for_mfa']}**.")
        qr_code_file = generate_qr_code(st.session_state["current_mfa_secret"], st.session_state["current_user_id_for_mfa"])
        st.image(qr_code_file, caption="Scan this QR code with your authenticator app", use_column_width=True)
        st.warning("Keep this QR code private. After scanning, use the 6-digit code from your app for future logins.")
        if st.button("I have scanned the QR code, proceed to login"):
            st.session_state["show_mfa_qr"] = False
            st.session_state["current_mfa_secret"] = None # Clear secret after use
            st.session_state["current_user_id_for_mfa"] = None # Clear user ID after use
            st.rerun() # Rerun to show the login page
    else:
        st.title("Access the ChainLearn Nexus")
        register_tab, login_tab = st.tabs(["Register", "Login"])
        
        with register_tab:
            st.subheader("Register")
            with st.form(key="register_form"):
                name = st.text_input("Full Name")
                role = st.selectbox("Select Role", ["Doctor", "Receptionist", "Patient"]) # Added Patient role
                password = st.text_input("Password", type="password")
                password_confirm = st.text_input("Confirm Password", type="password")
                register_button = st.form_submit_button("Register")
                
                if register_button:
                    if password == password_confirm:
                        cursor.execute("SELECT COUNT(*) FROM users1 WHERE role = ?", (role,))
                        count = cursor.fetchone()[0]
                        
                        user_id_prefix = ""
                        if role == "Doctor":
                            user_id_prefix = "10"
                        elif role == "Receptionist":
                            user_id_prefix = "20"
                        elif role == "Patient":
                            user_id_prefix = "30" # New prefix for patients
                            
                        user_id = f"{user_id_prefix}{1000 + count}"
                        
                        # Store SHA256 hash, its salt, and the bcrypt hash of the SHA256 hash
                        sha256_hashed_password, sha256_salt_hex, bcrypt_hashed_password = hash_password(password)
                        
                        # Generate MFA secret
                        mfa_secret = pyotp.random_base32()

                        cursor.execute(
                            "INSERT INTO users1 (user_id, name, role, password, salt, bcrypt_hash, mfa_secret) VALUES (?, ?, ?, ?, ?, ?, ?)",
                            (user_id, name, role, sha256_hashed_password, sha256_salt_hex, bcrypt_hashed_password, mfa_secret)
                        )
                        conn.commit()
                        st.success(f"Registration Successful! Your User ID is {user_id}. Please proceed to MFA setup.")
                        
                        # Set session state to show MFA QR code
                        st.session_state["show_mfa_qr"] = True
                        st.session_state["current_mfa_secret"] = mfa_secret
                        st.session_state["current_user_id_for_mfa"] = user_id
                        st.rerun() # Rerun to trigger the MFA QR display section
                    else:
                        st.error("Passwords do not match.")
        
        with login_tab:
            st.subheader("Login")
            with st.form(key="login_form"):
                user_id = st.text_input("User ID")
                password = st.text_input("Password", type="password")
                mfa_code = st.text_input("MFA Code (from your authenticator app)", type="password") # New MFA input field
                submit_button = st.form_submit_button("Log In")
                
                if submit_button:
                    # Fetch all relevant password and MFA components
                    cursor.execute("SELECT user_id, name, role, password, salt, bcrypt_hash, mfa_secret FROM users1 WHERE user_id = ?", (user_id,))
                    user = cursor.fetchone() # user[3] is password (SHA256), user[4] is salt (SHA256), user[5] is bcrypt_hash, user[6] is mfa_secret
                    
                    if user and verify_password(user[3], user[4], user[5], password):
                        stored_mfa_secret = user[6]
                        if stored_mfa_secret:
                            totp = pyotp.TOTP(stored_mfa_secret)
                            if totp.verify(mfa_code):
                                st.session_state["logged_in"] = True
                                st.session_state["user_id"] = user[0] # user_id
                                st.session_state["role"] = user[2] # role
                                st.session_state["name"] = user[1] # name
                                st.success(f"Login Successful! Welcome, {user[1]}")
                                st.rerun()
                            else:
                                st.error("Invalid MFA code.")
                        else:
                            st.error("MFA not set up for this user. Please register or contact support.")
                    else:
                        st.error("Invalid credentials.")

# --- Main App Logic for Doctor Role ---
if st.session_state['logged_in'] and st.session_state['role'] == "Doctor":
    st.write(f"Welcome, **{st.session_state['name']}** (User ID: **{st.session_state['user_id']}**)")
    
    # --- MODIFICATION: Load models from FL server ---
    diabetes_model = get_global_model("diabetes")
    heart_disease_model = get_global_model("heart") # Fetch heart model from FL server
    parkinsons_model = get_global_model("parkinsons") # NEW: Fetch Parkinson's model from FL server
    
    with st.sidebar:
        selected = option_menu(
            "ChainLearn Nexus",
            [
                "Diabetes",
                "Heart Disease",
                "Parkinson's",
                "SQL Records",
                "About",
                "Developed By",
                "Logout",
            ],
            icons=["activity", "heart", "person", "database", "link", "bi-info-circle", "bi-person-lines-fill" ,"box-arrow-right"],
            default_index=0,
        )
    
    # --- NEW: Buttons to manually send client data to server ---
    st.sidebar.markdown("---")
    st.sidebar.subheader("Federated Learning Sync")
    if st.sidebar.button("Sync My Diabetes Data with FL Server"):
        if send_diabetes_client_data_to_server(st.session_state["user_id"]):
            st.sidebar.success("Diabetes data synced!")
        else:
            st.sidebar.error("Diabetes data sync failed or no new data to send.")
            
    if st.sidebar.button("Sync My Heart Data with FL Server"):
        if send_heart_client_data_to_server(st.session_state["user_id"]):
            st.sidebar.success("Heart data synced!")
        else:
            st.sidebar.error("Heart data sync failed or no new data to send.")

    if st.sidebar.button("Sync My Parkinson's Data with FL Server"): # NEW: Parkinson's sync button
        if send_parkinsons_client_data_to_server(st.session_state["user_id"]):
            st.sidebar.success("Parkinson's data synced!")
        else:
            st.sidebar.error("Parkinson's data sync failed or no new data to send.")
            
    st.sidebar.markdown("---")

    # Diabetes Prediction Page
    if selected == 'Diabetes':
        st.title('Diabetes Prediction')

        if diabetes_model is None:
            st.warning("Diabetes prediction is unavailable. Could not load model from Federated Learning Server.")
            st.stop() # Stop execution if model isn't available
        
        st.subheader("Load Sample Data")
        col_diab_samples = st.columns(4)
        with col_diab_samples[0]:
            if st.button("Sample 1", key="diab_sample1_btn"):
                st.session_state["diab_pregnancies"] = "6"
                st.session_state["diab_glucose"] = "148"
                st.session_state["diab_bp"] = "72"
                st.session_state["diab_skin_thickness"] = "35"
                st.session_state["diab_insulin"] = "0"
                st.session_state["diab_bmi"] = "33.6"
                st.session_state["diab_dpf"] = "0.627"
                st.session_state["diab_age"] = "50"
                st.rerun()
        with col_diab_samples[1]:
            if st.button("Sample 2", key="diab_sample2_btn"):
                st.session_state["diab_pregnancies"] = "1"
                st.session_state["diab_glucose"] = "85"
                st.session_state["diab_bp"] = "66"
                st.session_state["diab_skin_thickness"] = "29"
                st.session_state["diab_insulin"] = "0"
                st.session_state["diab_bmi"] = "26.6"
                st.session_state["diab_dpf"] = "0.351"
                st.session_state["diab_age"] = "31"
                st.rerun()
        with col_diab_samples[2]:
            if st.button("Sample 3", key="diab_sample3_btn"):
                st.session_state["diab_pregnancies"] = "8"
                st.session_state["diab_glucose"] = "183"
                st.session_state["diab_bp"] = "64"
                st.session_state["diab_skin_thickness"] = "0"
                st.session_state["diab_insulin"] = "0"
                st.session_state["diab_bmi"] = "23.3"
                st.session_state["diab_dpf"] = "0.672"
                st.session_state["diab_age"] = "32"
                st.rerun()
        with col_diab_samples[3]:
            if st.button("Sample 4", key="diab_sample4_btn"):
                st.session_state["diab_pregnancies"] = "1"
                st.session_state["diab_glucose"] = "89"
                st.session_state["diab_bp"] = "66"
                st.session_state["diab_skin_thickness"] = "23"
                st.session_state["diab_insulin"] = "94"
                st.session_state["diab_bmi"] = "28.1"
                st.session_state["diab_dpf"] = "0.167"
                st.session_state["diab_age"] = "21"
                st.rerun()


        col1, col2, col3 = st.columns(3)
        with col1:
            Pregnancies = st.text_input('Number of Pregnancies', value=st.session_state["diab_pregnancies"], key="diab_pregnancies")
        with col2:
            Glucose = st.text_input('Glucose Level', value=st.session_state["diab_glucose"], key="diab_glucose")
        with col3:
            BloodPressure = st.text_input('Blood Pressure value', value=st.session_state["diab_bp"], key="diab_bp")
        with col1:
            SkinThickness = st.text_input('Skin Thickness value', value=st.session_state["diab_skin_thickness"], key="diab_skin_thickness")
        with col2:
            Insulin = st.text_input('Insulin Level', value=st.session_state["diab_insulin"], key="diab_insulin")
        with col3:
            BMI = st.text_input('BMI value', value=st.session_state["diab_bmi"], key="diab_bmi")
        with col1:
            DiabetesPedigreeFunction = st.text_input('Diabetes Pedigree Function value', value=st.session_state["diab_dpf"], key="diab_dpf")
        with col2:
            Age = st.text_input('Age of the Person', value=st.session_state["diab_age"], key="diab_age")

        diab_diagnosis = ''
        result = '' # This will store 'Yes' or 'No'
        name = st.session_state.get('name')
        user_id = st.session_state.get('user_id')
        current_datetime = datetime.datetime.now()
        date = current_datetime.strftime("%Y-%m-%d")
        time = current_datetime.strftime("%H:%M:%S")

        if st.button('Diabetes Test Result'):
            try:
                user_input_values = [Pregnancies, Glucose, BloodPressure, SkinThickness, Insulin,
                                     BMI, DiabetesPedigreeFunction, Age]
                
                # Check for empty inputs and convert to float
                if any(val == '' for val in user_input_values):
                    st.error("Please fill in all prediction input fields.")
                    st.stop()
                    
                user_input_float = [float(x) for x in user_input_values]
                
                # Make prediction using the loaded FL model
                diab_prediction = diabetes_model.predict([user_input_float])

                if diab_prediction[0] == 1:
                    diab_diagnosis = 'The person is diabetic'
                    result = 'Yes'
                else:
                    diab_diagnosis = 'The person is not diabetic'
                    result = 'No'
                st.success(diab_diagnosis)
                st.session_state["diab_prediction_result"] = result # Store the result in session state

                # --- MODIFICATION: Store data locally for FL server ---
                # Prepare data for local storage and eventual upload to FL server
                prediction_data_for_fl = {
                    'Pregnancies': float(Pregnancies),
                    'Glucose': float(Glucose),
                    'BloodPressure': float(BloodPressure),
                    'SkinThickness': float(SkinThickness),
                    'Insulin': float(Insulin),
                    'BMI': float(BMI),
                    'DiabetesPedigreeFunction': float(DiabetesPedigreeFunction),
                    'Age': float(Age),
                    'Outcome': 1 if result == 'Yes' else 0 # Convert 'Yes'/'No' to 1/0 for ML training
                }
                append_client_diabetes_data(prediction_data_for_fl, user_id)
                # --- END MODIFICATION ---

                # NEW: Hash test result data before storing in SQLite DB
                hashed_user_id, user_id_salt = hash_data_field(user_id)
                hashed_name, name_salt = hash_data_field(name)
                hashed_date, date_salt = hash_data_field(date)
                hashed_time, time_salt = hash_data_field(time)
                hashed_disease, disease_salt = hash_data_field('Diabetes')
                hashed_result, result_salt = hash_data_field(result)

                # Generate combined bcrypt hash for record integrity
                combined_hashes = [hashed_user_id, hashed_name, hashed_date, hashed_time, hashed_disease, hashed_result]
                combined_bcrypt_hash = hash_record_integrity(combined_hashes)

                cursor.execute('''INSERT INTO test_results1 (user_id_hash, user_id_salt, name_hash, name_salt, 
                                 date_hash, date_salt, time_hash, time_salt, disease_hash, disease_salt, 
                                 result_hash, result_salt, combined_bcrypt_hash)
                                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''', 
                                 (hashed_user_id, user_id_salt, hashed_name, name_salt, hashed_date, date_salt, 
                                  hashed_time, time_salt, hashed_disease, disease_salt, hashed_result, result_salt, 
                                  combined_bcrypt_hash))
                conn.commit()
                st.success("Record stored in local Database successfully!")

            except ValueError:
                st.error("Please enter valid numerical values for all inputs.")
            except Exception as e:
                st.error(f"Error in prediction: {e}")
        
        # Show Popup For Patient Information and Report Generation
        show_popup_diabetes = st.checkbox("Click To Enter Patient Details:", key="diabetes_details_checkbox")
        if show_popup_diabetes:
            # Initialize session state for patient details if they don't exist
            # This ensures form fields retain values across reruns
            if "patient_name" not in st.session_state:
                st.session_state["patient_name"] = ""
                st.session_state["patient_id_report"] = "" # To store the patient ID for report generation
                st.session_state["patient_address"] = ""
                st.session_state["patient_contact_number"] = ""
                st.session_state["patient_email"] = ""
                st.session_state["patient_gender"] = ""
                st.session_state["patient_age"] = ""
                st.session_state["doctors_name"] = ""
                st.session_state["show_download"] = False # Control download button visibility

            patient_name = st.text_input("Patient Name", value=st.session_state["patient_name"], key="input_patient_name")
            # For report generation, ensure patient_id is explicitly captured or linked from logged-in user if Doctor
            # If receptionist, this should be the patient's registered user_id.
            patient_id_report = st.text_input("Patient User ID (e.g., 301000 for registered patient)", value=st.session_state["patient_id_report"], key="input_patient_id_report")
            patient_address = st.text_input("Address", value=st.session_state["patient_address"], key="input_patient_address")
            patient_contact_number = st.text_input("Contact Number", value=st.session_state["patient_contact_number"], key="input_patient_contact")
            patient_email = st.text_input("Email", value=st.session_state["patient_email"], key="input_patient_email")
            
            # Find current index for selectbox based on session state
            gender_options = ["Male", "Female", "Other"]
            current_gender_index = gender_options.index(st.session_state["patient_gender"]) if st.session_state["patient_gender"] else 0
            patient_gender = st.selectbox("Gender", gender_options, index=current_gender_index, key="input_patient_gender")
            
            patient_age = st.text_input("Age", value=st.session_state["patient_age"], key="input_patient_age")
            doctors_name = st.text_input("Doctor Name", value=st.session_state["doctors_name"], key="input_doctors_name")
            
            if st.button("Submit Patient Details"):
                if not patient_id_report:
                    st.error("Please enter the Patient User ID for report generation.")
                    st.stop()
                if st.session_state["diab_prediction_result"] is None:
                    st.error("Please run the Diabetes prediction first before submitting patient details for the report.")
                    st.stop()
                # Update session state with submitted details
                st.session_state["patient_name"] = patient_name
                st.session_state["patient_id_report"] = patient_id_report
                st.session_state["patient_address"] = patient_address
                st.session_state["patient_contact_number"] = patient_contact_number
                st.session_state["patient_email"] = patient_email
                st.session_state["patient_gender"] = patient_gender
                st.session_state["patient_age"] = patient_age
                st.session_state["doctors_name"] = doctors_name
                st.success("Patient Details Submitted!")
                st.session_state["show_download"] = True # Enable download button after submission

            if st.session_state.get("show_download", False) and st.session_state["patient_id_report"]:
                class PDF(FPDF):
                    def header(self):
                        self.set_fill_color(119, 185, 71)
                        self.set_text_color(255, 255, 255)
                        self.set_font("Arial", "B", 18)
                        self.cell(0, 20, "ChainLearn Nexus Lab", ln=True, align='C', fill=True)
                        self.ln(5)

                    def footer(self):
                        self.set_y(-15)
                        self.set_font('Arial', 'I', 8)
                        self.set_text_color(128)
                        self.cell(0, 10, f'Page {self.page_no()}', 0, 0, 'C')

                pdf = PDF()
                pdf.add_page()
                pdf.set_font("Arial", size=12)
                pdf.cell(200, 10, "", ln=True) # Spacer
                pdf.set_text_color(0, 0, 0)
                pdf.set_font("Arial", size=12)

                # Patient and Doctor Details
                pdf.set_font("Arial", size=12)
                pdf.cell(95, 10, f"Patient Name: {st.session_state['patient_name']}", border=1, align='L')
                pdf.cell(95, 10, f"Patient ID: {st.session_state['patient_id_report']}", border=1, align='L') # Display Patient ID
                pdf.ln()
                pdf.cell(95, 10, f"Address: {st.session_state['patient_address']}", border=1, align='L')
                pdf.cell(95, 10, f"Contact Number: {st.session_state['patient_contact_number']}", border=1, align='L')
                pdf.ln()
                pdf.cell(95, 10, f"Email: {st.session_state['patient_email']}", border=1, align='L')
                pdf.cell(95, 10, f"Gender: {st.session_state['patient_gender']}", border=1, align='L')
                pdf.ln()
                pdf.cell(95, 10, f"Age: {st.session_state['patient_age']}", border=1, align='L')
                pdf.cell(95, 10, f"Doctor's Name: {st.session_state['doctors_name']}", border=1, align='L')
                pdf.ln()
                pdf.cell(95, 10, f"Date: {date}", border=1, align='L')
                pdf.cell(95, 10, f"Time: {time}", border=1, align='L')
                pdf.ln()
                
                # Ensure 'result' variable is available from the prediction block
                # diabetes_result_text = "N/A (Run prediction first)" 
                if st.session_state["diab_prediction_result"] is not None: # Check if result was actually set by a prediction
                    diabetes_result_text = "Diabetic" if st.session_state["diab_prediction_result"].strip().lower() == "yes" else "Not Diabetic"
                else:
                    diabetes_result_text = "N/A (Run prediction first)" # Default if no prediction yet
                pdf.set_font("Arial", style='B', size=12)
                pdf.cell(95, 10, f"Diabetes Result: {diabetes_result_text}", border=1, align='L')
                pdf.ln()

                pdf.ln(10)
                pdf.set_fill_color(200, 200, 200)
                pdf.cell(95, 10, "Parameter", border=1, fill=True, align='C')
                pdf.cell(95, 10, "Value", border=1, fill=True, align='C')
                pdf.ln()

                data = [("Pregnancies", Pregnancies), ("Glucose", Glucose),
                        ("Blood Pressure", BloodPressure), ("Skin Thickness", SkinThickness),
                        ("Insulin", Insulin), ("BMI", BMI),
                        ("Diabetes Pedigree Function", DiabetesPedigreeFunction), ("Age", Age)]
            
                for param, value in data:
                    pdf.cell(95, 10, param, border=1, align='C')
                    pdf.cell(95, 10, str(value), border=1, align='C') # Ensure value is string
                    pdf.ln()

                pdf.ln(10)
                pdf.cell(200, 10, "Special Instruction By Doctor :", ln=True)
                pdf.ln(40)
                pdf.set_font("Courier", size=12)
                pdf.cell(200, 10, f"Approved By: ChainLearn Nexus Lab   Signed By: {name}", ln=True, align='C')
            
                output_dir = r"./Report/Diabetes_Reports"
                os.makedirs(output_dir, exist_ok=True)
                # NEW PDF NAMING: patient_name_patient_id_disease_report.pdf
                pdf_output = os.path.join(output_dir, f"{st.session_state['patient_name']}_{st.session_state['patient_id_report']}_diabetes_report.pdf")
                pdf.output(pdf_output)

                with open(pdf_output, "rb") as file:
                    st.download_button(label="Download Report", data=file, file_name=f"{st.session_state['patient_name']}_{st.session_state['patient_id_report']}_diabetes_report.pdf", mime="application/pdf")

    # --- Heart Disease Prediction Page ---
    elif selected == 'Heart Disease':
        st.title("Heart Disease Prediction")
        if heart_disease_model is None:
            st.warning("Heart Disease prediction is unavailable. Could not load model from Federated Learning Server.")
            st.stop()
        
        st.subheader("Load Sample Data")
        col_heart_samples = st.columns(4)
        with col_heart_samples[0]:
            if st.button("Sample 1", key="heart_sample1_btn"):
                st.session_state["heart_age"] = "63"
                st.session_state["heart_sex"] = "1"
                st.session_state["heart_cp"] = "3"
                st.session_state["heart_trestbps"] = "145"
                st.session_state["heart_chol"] = "233"
                st.session_state["heart_fbs"] = "1"
                st.session_state["heart_restecg"] = "0"
                st.session_state["heart_thalach"] = "150"
                st.session_state["heart_exang"] = "0"
                st.session_state["heart_oldpeak"] = "2.3"
                st.session_state["heart_slope"] = "0"
                st.session_state["heart_ca"] = "0"
                st.session_state["heart_thal"] = "1"
                st.rerun()
        with col_heart_samples[1]:
            if st.button("Sample 2", key="heart_sample2_btn"):
                st.session_state["heart_age"] = "37"
                st.session_state["heart_sex"] = "1"
                st.session_state["heart_cp"] = "2"
                st.session_state["heart_trestbps"] = "130"
                st.session_state["heart_chol"] = "250"
                st.session_state["heart_fbs"] = "0"
                st.session_state["heart_restecg"] = "1"
                st.session_state["heart_thalach"] = "187"
                st.session_state["heart_exang"] = "0"
                st.session_state["heart_oldpeak"] = "3.5"
                st.session_state["heart_slope"] = "0"
                st.session_state["heart_ca"] = "0"
                st.session_state["heart_thal"] = "2"
                st.rerun()
        with col_heart_samples[2]:
            if st.button("Sample 3", key="heart_sample3_btn"):
                st.session_state["heart_age"] = "67"
                st.session_state["heart_sex"] = "1"
                st.session_state["heart_cp"] = "0"
                st.session_state["heart_trestbps"] = "160"
                st.session_state["heart_chol"] = "286"
                st.session_state["heart_fbs"] = "0"
                st.session_state["heart_restecg"] = "0"
                st.session_state["heart_thalach"] = "108"
                st.session_state["heart_exang"] = "1"
                st.session_state["heart_oldpeak"] = "1.5"
                st.session_state["heart_slope"] = "1"
                st.session_state["heart_ca"] = "3"
                st.session_state["heart_thal"] = "2"
                st.rerun()
        with col_heart_samples[3]:
            if st.button("Sample 4", key="heart_sample4_btn"):
                st.session_state["heart_age"] = "67"
                st.session_state["heart_sex"] = "1"
                st.session_state["heart_cp"] = "0"
                st.session_state["heart_trestbps"] = "120"
                st.session_state["heart_chol"] = "229"
                st.session_state["heart_fbs"] = "0"
                st.session_state["heart_restecg"] = "0"
                st.session_state["heart_thalach"] = "129"
                st.session_state["heart_exang"] = "1"
                st.session_state["heart_oldpeak"] = "2.6"
                st.session_state["heart_slope"] = "1"
                st.session_state["heart_ca"] = "2"
                st.session_state["heart_thal"] = "3"
                st.rerun()

        # User input for Heart Disease prediction
        col1, col2, col3 = st.columns(3)
        with col1:
            age = st.text_input('Age', value=st.session_state["heart_age"], key="heart_age")
        with col2:
            sex = st.text_input('Sex (0 = Female, 1 = Male)', value=st.session_state["heart_sex"], key="heart_sex")
        with col3:
            cp = st.text_input('Chest Pain Type (0-3)', value=st.session_state["heart_cp"], key="heart_cp")
        with col1:
            trestbps = st.text_input('Resting Blood Pressure', value=st.session_state["heart_trestbps"], key="heart_trestbps")
        with col2:
            chol = st.text_input('Serum Cholestoral in mg/dl', value=st.session_state["heart_chol"], key="heart_chol")
        with col3:
            fbs = st.text_input('Fasting Blood Sugar > 120 mg/dl (0 = No, 1 = Yes)', value=st.session_state["heart_fbs"], key="heart_fbs")
        with col1:
            restecg = st.text_input('Resting Electrocardiographic results (0-2)', value=st.session_state["heart_restecg"], key="heart_restecg")
        with col2:
            thalach = st.text_input('Maximum Heart Rate achieved', value=st.session_state["heart_thalach"], key="heart_thalach")
        with col3:
            exang = st.text_input('Exercise Induced Angina (0 = No, 1 = Yes)', value=st.session_state["heart_exang"], key="heart_exang")
        with col1:
            oldpeak = st.text_input('ST depression induced by exercise relative to rest', value=st.session_state["heart_oldpeak"], key="heart_oldpeak")
        with col2:
            slope = st.text_input('Slope of the peak exercise ST segment (0-2)', value=st.session_state["heart_slope"], key="heart_slope")
        with col3:
            ca = st.text_input('Number of major vessels (0-3) colored by flourosopy', value=st.session_state["heart_ca"], key="heart_ca")
        with col1:
            thal = st.text_input('Thal: 0 = normal; 1 = fixed defect; 2 = reversable defect', value=st.session_state["heart_thal"], key="heart_thal")

        heart_diagnosis = ''
        result = '' # This will store 'Yes' or 'No'
        name = st.session_state.get('name')
        user_id = st.session_state.get('user_id')
        current_datetime = datetime.datetime.now()
        date = current_datetime.strftime("%Y-%m-%d")
        time = current_datetime.strftime("%H:%M:%S")

        if st.button('Heart Disease Test Result'):
            try:
                # Convert inputs to numerical values
                input_data = [age, sex, cp, trestbps, chol, fbs, restecg, thalach, exang, oldpeak, slope, ca, thal]
                if any(val == '' for val in input_data):
                    st.error("Please fill in all prediction input fields.")
                    st.stop()
                
                user_input_float = [float(x) for x in input_data]
                input_data_reshaped = np.asarray(user_input_float).reshape(1, -1)

                heart_prediction = heart_disease_model.predict(input_data_reshaped)

                if (heart_prediction[0] == 1):
                    heart_diagnosis = 'The person is having heart disease'
                    result = 'Yes'
                else:
                    heart_diagnosis = 'The person is not having heart disease'
                    result = 'No'
                st.success(heart_diagnosis)
                st.session_state["heart_prediction_result"] = result # Store the result in session state

                # --- NEW: Store data locally for FL server for Heart Disease ---
                prediction_data_for_fl = {
                    'age': float(age), 'sex': float(sex), 'cp': float(cp), 'trestbps': float(trestbps),
                    'chol': float(chol), 'fbs': float(fbs), 'restecg': float(restecg), 'thalach': float(thalach),
                    'exang': float(exang), 'oldpeak': float(oldpeak), 'slope': float(slope), 'ca': float(ca),
                    'thal': float(thal),
                    'Outcome': 1 if result == 'Yes' else 0 # Convert 'Yes'/'No' to 1/0 for ML training
                }
                append_client_heart_data(prediction_data_for_fl, user_id)
                # --- END NEW ---

                # NEW: Hash test result data before storing in SQLite DB
                hashed_user_id, user_id_salt = hash_data_field(user_id)
                hashed_name, name_salt = hash_data_field(name)
                hashed_date, date_salt = hash_data_field(date)
                hashed_time, time_salt = hash_data_field(time)
                hashed_disease, disease_salt = hash_data_field('Heart Disease')
                hashed_result, result_salt = hash_data_field(result)

                # Generate combined bcrypt hash for record integrity
                combined_hashes = [hashed_user_id, hashed_name, hashed_date, hashed_time, hashed_disease, hashed_result]
                combined_bcrypt_hash = hash_record_integrity(combined_hashes)

                cursor.execute('''INSERT INTO test_results1 (user_id_hash, user_id_salt, name_hash, name_salt, 
                                 date_hash, date_salt, time_hash, time_salt, disease_hash, disease_salt, 
                                 result_hash, result_salt, combined_bcrypt_hash)
                                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''', 
                                 (hashed_user_id, user_id_salt, hashed_name, name_salt, hashed_date, date_salt, 
                                  hashed_time, time_salt, hashed_disease, disease_salt, hashed_result, result_salt, 
                                  combined_bcrypt_hash))
                conn.commit()
                st.success("Record stored in local Database successfully!")

            except ValueError:
                st.error("Please enter valid numerical values for all inputs.")
            except Exception as e:
                st.error(f"Error in prediction: {e}")
        
        # Show Popup For Patient Information and Report Generation (Heart Disease)
        show_popup_heart = st.checkbox("Click To Enter Patient Details:", key="heart_details_checkbox")
        if show_popup_heart:
            # Initialize session state for patient details if they don't exist
            if "heart_patient_name" not in st.session_state:
                st.session_state["heart_patient_name"] = ""
                st.session_state["heart_patient_id_report"] = ""
                st.session_state["heart_patient_address"] = ""
                st.session_state["heart_patient_contact_number"] = ""
                st.session_state["heart_patient_email"] = ""
                st.session_state["heart_patient_gender"] = ""
                st.session_state["heart_patient_age"] = ""
                st.session_state["heart_doctors_name"] = ""
                st.session_state["heart_show_download"] = False
            
            patient_name = st.text_input("Patient Name", value=st.session_state["heart_patient_name"], key="input_heart_patient_name")
            patient_id_report = st.text_input("Patient User ID (e.g., 301000 for registered patient)", value=st.session_state["heart_patient_id_report"], key="input_heart_patient_id_report")
            patient_address = st.text_input("Address", value=st.session_state["heart_patient_address"], key="input_heart_patient_address")
            patient_contact_number = st.text_input("Contact Number", value=st.session_state["heart_patient_contact_number"], key="input_heart_patient_contact")
            patient_email = st.text_input("Email", value=st.session_state["heart_patient_email"], key="input_heart_patient_email")
            
            gender_options = ["Male", "Female", "Other"]
            current_gender_index = gender_options.index(st.session_state["heart_patient_gender"]) if st.session_state["heart_patient_gender"] else 0
            patient_gender = st.selectbox("Gender", gender_options, index=current_gender_index, key="input_heart_patient_gender")
            
            patient_age = st.text_input("Age", value=st.session_state["heart_patient_age"], key="input_heart_patient_age")
            doctors_name = st.text_input("Doctor Name", value=st.session_state["heart_doctors_name"], key="input_heart_doctors_name")
            
            if st.button("Submit Patient Details", key="submit_heart_patient_details"):
                if not patient_id_report:
                    st.error("Please enter the Patient User ID for report generation.")
                    st.stop()
                if st.session_state["heart_prediction_result"] is None:
                    st.error("Please run the Heart Disease prediction first before submitting patient details for the report.")
                    st.stop()
                st.session_state["heart_patient_name"] = patient_name
                st.session_state["heart_patient_id_report"] = patient_id_report
                st.session_state["heart_patient_address"] = patient_address
                st.session_state["heart_patient_contact_number"] = patient_contact_number
                st.session_state["heart_patient_email"] = patient_email
                st.session_state["heart_patient_gender"] = patient_gender
                st.session_state["heart_patient_age"] = patient_age
                st.session_state["heart_doctors_name"] = doctors_name
                st.success("Heart Patient Details Submitted!")
                st.session_state["heart_show_download"] = True

            if st.session_state.get("heart_show_download", False) and st.session_state["heart_patient_id_report"]:
                class PDF(FPDF):
                    def header(self):
                        self.set_fill_color(119, 185, 71)
                        self.set_text_color(255, 255, 255)
                        self.set_font("Arial", "B", 18)
                        self.cell(0, 20, "ChainLearn Nexus Lab", ln=True, align='C', fill=True)
                        self.ln(5)

                    def footer(self):
                        self.set_y(-15)
                        self.set_font('Arial', 'I', 8)
                        self.set_text_color(128)
                        self.cell(0, 10, f'Page {self.page_no()}', 0, 0, 'C')

                pdf = PDF()
                pdf.add_page()
                pdf.set_font("Arial", size=12)
                pdf.cell(200, 10, "", ln=True) # Spacer
                pdf.set_text_color(0, 0, 0)
                pdf.set_font("Arial", size=12)

                # Patient and Doctor Details
                pdf.set_font("Arial", size=12)
                pdf.cell(95, 10, f"Patient Name: {st.session_state['heart_patient_name']}", border=1, align='L')
                pdf.cell(95, 10, f"Patient ID: {st.session_state['heart_patient_id_report']}", border=1, align='L')
                pdf.ln()
                pdf.cell(95, 10, f"Address: {st.session_state['heart_patient_address']}", border=1, align='L')
                pdf.cell(95, 10, f"Contact Number: {st.session_state['heart_patient_contact_number']}", border=1, align='L')
                pdf.ln()
                pdf.cell(95, 10, f"Email: {st.session_state['heart_patient_email']}", border=1, align='L')
                pdf.cell(95, 10, f"Gender: {st.session_state['heart_patient_gender']}", border=1, align='L')
                pdf.ln()
                pdf.cell(95, 10, f"Age: {st.session_state['heart_patient_age']}", border=1, align='L')
                pdf.cell(95, 10, f"Doctor's Name: {st.session_state['heart_doctors_name']}", border=1, align='L')
                pdf.ln()
                pdf.cell(95, 10, f"Date: {date}", border=1, align='L')
                pdf.cell(95, 10, f"Time: {time}", border=1, align='L')
                pdf.ln()
                
                heart_result_text = "N/A (Run prediction first)" 
                if st.session_state["heart_prediction_result"] is not None: # Check if result was actually set by a prediction
                    heart_result_text = "Heart Disease" if st.session_state["heart_prediction_result"].strip().lower() == "yes" else "No Heart Disease"
                pdf.set_font("Arial", style='B', size=12)
                pdf.cell(95, 10, f"Heart Disease Result: {heart_result_text}", border=1, align='L')
                pdf.ln()

                pdf.ln(10)
                pdf.set_fill_color(200, 200, 200)
                pdf.cell(95, 10, "Parameter", border=1, fill=True, align='C')
                pdf.cell(95, 10, "Value", border=1, fill=True, align='C')
                pdf.ln()

                data = [
                    ("Age", age), ("Sex", sex), ("Chest Pain Type", cp), ("Resting Blood Pressure", trestbps),
                    ("Serum Cholestoral", chol), ("Fasting Blood Sugar > 120", fbs), 
                    ("Resting ECG Results", restecg), ("Max Heart Rate Achieved", thalach),
                    ("Exercise Induced Angina", exang), ("ST Depression", oldpeak), 
                    ("Slope of Peak Exercise ST Segment", slope), ("Number of Major Vessels", ca), 
                    ("Thal", thal)
                ]
            
                for param, value in data:
                    pdf.cell(95, 10, param, border=1, align='C')
                    pdf.cell(95, 10, str(value), border=1, align='C') # Ensure value is string
                    pdf.ln()

                pdf.ln(10)
                pdf.cell(200, 10, "Special Instruction By Doctor :", ln=True)
                pdf.ln(40)
                pdf.set_font("Courier", size=12)
                pdf.cell(200, 10, f"Approved By: ChainLearn Nexus Lab   Signed By: {name}", ln=True, align='C')
            
                output_dir = r"./Report/Heart_Reports"
                os.makedirs(output_dir, exist_ok=True)
                # NEW PDF NAMING: patient_name_patient_id_disease_report.pdf
                pdf_output = os.path.join(output_dir, f"{st.session_state['heart_patient_name']}_{st.session_state['heart_patient_id_report']}_heart_report.pdf")
                pdf.output(pdf_output)

                with open(pdf_output, "rb") as file:
                    st.download_button(label="Download Report", data=file, file_name=f"{st.session_state['heart_patient_name']}_{st.session_state['heart_patient_id_report']}_heart_report.pdf", mime="application/pdf")


    elif selected == "Parkinson's":
        st.title("Parkinson's Prediction")
        if parkinsons_model is None:
            st.warning("Parkinson's prediction is unavailable. Could not load model from Federated Learning Server.")
            st.stop()
        
        st.subheader("Load Sample Data")
        col_park_samples = st.columns(4)
        with col_park_samples[0]:
            if st.button("Sample 1", key="park_sample1_btn"):
                st.session_state["park_fo"] = "119.99200"
                st.session_state["park_fhi"] = "157.30200"
                st.session_state["park_flo"] = "74.99700"
                st.session_state["park_jitter_percent"] = "0.00784"
                st.session_state["park_jitter_abs"] = "0.00007"
                st.session_state["park_rap"] = "0.00370"
                st.session_state["park_ppq"] = "0.00554"
                st.session_state["park_ddp"] = "0.01109"
                st.session_state["park_shimmer"] = "0.04374"
                st.session_state["park_shimmer_db"] = "0.42600"
                st.session_state["park_apq3"] = "0.02182"
                st.session_state["park_apq5"] = "0.03130"
                st.session_state["park_apq"] = "0.02971"
                st.session_state["park_dda"] = "0.06545"
                st.session_state["park_nhr"] = "0.02211"
                st.session_state["park_hnr"] = "21.03300"
                st.session_state["park_rpde"] = "0.414783"
                st.session_state["park_dfa"] = "0.815285"
                st.session_state["park_spread1"] = "-4.813031"
                st.session_state["park_spread2"] = "0.266482"
                st.session_state["park_d2"] = "2.301442"
                st.session_state["park_ppe"] = "0.284654"
                st.rerun()
        with col_park_samples[1]:
            if st.button("Sample 2", key="park_sample2_btn"):
                st.session_state["park_fo"] = "122.40000"
                st.session_state["park_fhi"] = "148.65000"
                st.session_state["park_flo"] = "113.81900"
                st.session_state["park_jitter_percent"] = "0.00968"
                st.session_state["park_jitter_abs"] = "0.00008"
                st.session_state["park_rap"] = "0.00465"
                st.session_state["park_ppq"] = "0.00696"
                st.session_state["park_ddp"] = "0.01394"
                st.session_state["park_shimmer"] = "0.06134"
                st.session_state["park_shimmer_db"] = "0.62600"
                st.session_state["park_apq3"] = "0.03134"
                st.session_state["park_apq5"] = "0.04518"
                st.session_state["park_apq"] = "0.04368"
                st.session_state["park_dda"] = "0.09403"
                st.session_state["park_nhr"] = "0.01929"
                st.session_state["park_hnr"] = "19.08500"
                st.session_state["park_rpde"] = "0.458359"
                st.session_state["park_dfa"] = "0.819521"
                st.session_state["park_spread1"] = "-4.075192"
                st.session_state["park_spread2"] = "0.335590"
                st.session_state["park_d2"] = "2.486855"
                st.session_state["park_ppe"] = "0.368674"
                st.rerun()
        with col_park_samples[2]:
            if st.button("Sample 3", key="park_sample3_btn"):
                st.session_state["park_fo"] = "237.22600"
                st.session_state["park_fhi"] = "247.32600"
                st.session_state["park_flo"] = "225.22700"
                st.session_state["park_jitter_percent"] = "0.00298"
                st.session_state["park_jitter_abs"] = "0.00001"
                st.session_state["park_rap"] = "0.00169"
                st.session_state["park_ppq"] = "0.00182"
                st.session_state["park_ddp"] = "0.00507"
                st.session_state["park_shimmer"] = "0.01752"
                st.session_state["park_shimmer_db"] = "0.16400"
                st.session_state["park_apq3"] = "0.01035"
                st.session_state["park_apq5"] = "0.01024"
                st.session_state["park_apq"] = "0.01133"
                st.session_state["park_dda"] = "0.03104"
                st.session_state["park_nhr"] = "0.00740"
                st.session_state["park_hnr"] = "22.73600"
                st.session_state["park_rpde"] = "0.305062"
                st.session_state["park_dfa"] = "0.654172"
                st.session_state["park_spread1"] = "-7.310550"
                st.session_state["park_spread2"] = "0.098648"
                st.session_state["park_d2"] = "2.416838"
                st.session_state["park_ppe"] = "0.095032"
                st.rerun()
        with col_park_samples[3]:
            if st.button("Sample 4", key="park_sample4_btn"):
                st.session_state["park_fo"] = "241.40400"
                st.session_state["park_fhi"] = "248.83400"
                st.session_state["park_flo"] = "232.48300"
                st.session_state["park_jitter_percent"] = "0.00281"
                st.session_state["park_jitter_abs"] = "0.00001"
                st.session_state["park_rap"] = "0.00157"
                st.session_state["park_ppq"] = "0.00173"
                st.session_state["park_ddp"] = "0.00470"
                st.session_state["park_shimmer"] = "0.01760"
                st.session_state["park_shimmer_db"] = "0.15400"
                st.session_state["park_apq3"] = "0.01006"
                st.session_state["park_apq5"] = "0.01038"
                st.session_state["park_apq"] = "0.01251"
                st.session_state["park_dda"] = "0.03017"
                st.session_state["park_nhr"] = "0.00675"
                st.session_state["park_hnr"] = "23.14500"
                st.session_state["park_rpde"] = "0.457702"
                st.session_state["park_dfa"] = "0.634267"
                st.session_state["park_spread1"] = "-6.793547"
                st.session_state["park_spread2"] = "0.158266"
                st.session_state["park_d2"] = "2.256699"
                st.session_state["park_ppe"] = "0.117399"
                st.rerun()

        col1, col2, col3 = st.columns(3)
        with col1:
            fo = st.text_input('MDVP:Fo(Hz)', value=st.session_state["park_fo"], key="park_fo")
        with col2:
            fhi = st.text_input('MDVP:Fhi(Hz)', value=st.session_state["park_fhi"], key="park_fhi")
        with col3:
            flo = st.text_input('MDVP:Flo(Hz)', value=st.session_state["park_flo"], key="park_flo")
        with col1:
            Jitter_percent = st.text_input('MDVP:Jitter(%)', value=st.session_state["park_jitter_percent"], key="park_jitter_percent")
        with col2:
            Jitter_Abs = st.text_input('MDVP:Jitter(Abs)', value=st.session_state["park_jitter_abs"], key="park_jitter_abs")
        with col3:
            RAP = st.text_input('MDVP:RAP', value=st.session_state["park_rap"], key="park_rap")
        with col1:
            PPQ = st.text_input('MDVP:PPQ', value=st.session_state["park_ppq"], key="park_ppq")
        with col2:
            DDP = st.text_input('Jitter:DDP', value=st.session_state["park_ddp"], key="park_ddp")
        with col3:
            Shimmer = st.text_input('MDVP:Shimmer', value=st.session_state["park_shimmer"], key="park_shimmer")
        with col1:
            Shimmer_dB = st.text_input('MDVP:Shimmer(dB)', value=st.session_state["park_shimmer_db"], key="park_shimmer_db")
        with col2:
            APQ3 = st.text_input('Shimmer:APQ3', value=st.session_state["park_apq3"], key="park_apq3")
        with col3:
            APQ5 = st.text_input('Shimmer:APQ5', value=st.session_state["park_apq5"], key="park_apq5")
        with col1:
            APQ = st.text_input('MDVP:APQ', value=st.session_state["park_apq"], key="park_apq")
        with col2:
            DDA = st.text_input('Shimmer:DDA', value=st.session_state["park_dda"], key="park_dda")
        with col3:
            NHR = st.text_input('NHR', value=st.session_state["park_nhr"], key="park_nhr")
        with col1:
            HNR = st.text_input('HNR', value=st.session_state["park_hnr"], key="park_hnr")
        with col2:
            RPDE = st.text_input('RPDE', value=st.session_state["park_rpde"], key="park_rpde")
        with col3:
            DFA = st.text_input('DFA', value=st.session_state["park_dfa"], key="park_dfa")
        with col1:
            spread1 = st.text_input('spread1', value=st.session_state["park_spread1"], key="park_spread1")
        with col2:
            spread2 = st.text_input('spread2', value=st.session_state["park_spread2"], key="park_spread2")
        with col3:
            D2 = st.text_input('D2', value=st.session_state["park_d2"], key="park_d2")
        with col1:
            PPE = st.text_input('PPE', value=st.session_state["park_ppe"], key="park_ppe")

        parkinsons_diagnosis = ''
        result = '' # This will store 'Yes' or 'No'
        name = st.session_state.get('name')
        user_id = st.session_state.get('user_id')
        current_datetime = datetime.datetime.now()
        date = current_datetime.strftime("%Y-%m-%d")
        time = current_datetime.strftime("%H:%M:%S")

        if st.button("Parkinson's Test Result"):
            try:
                # Convert inputs to numerical values
                input_data = [fo, fhi, flo, Jitter_percent, Jitter_Abs, RAP, PPQ, DDP, Shimmer,
                              Shimmer_dB, APQ3, APQ5, APQ, DDA, NHR, HNR, RPDE, DFA, spread1, spread2, D2, PPE]
                
                if any(val == '' for val in input_data):
                    st.error("Please fill in all prediction input fields.")
                    st.stop()

                user_input_float = [float(x) for x in input_data]
                input_data_reshaped = np.asarray(user_input_float).reshape(1, -1)

                parkinsons_prediction = parkinsons_model.predict(input_data_reshaped)

                if (parkinsons_prediction[0] == 1):
                    parkinsons_diagnosis = "The person has Parkinson's Disease"
                    result = 'Yes'
                else:
                    parkinsons_diagnosis = "The person does not have Parkinson's Disease"
                    result = 'No'
                st.success(parkinsons_diagnosis)
                st.session_state["parkinsons_prediction_result"] = result # Store the result in session state

                # --- NEW: Store data locally for FL server for Parkinson's ---
                prediction_data_for_fl = {
                    'fo': float(fo), 'fhi': float(fhi), 'flo': float(flo), 'Jitter_percent': float(Jitter_percent),
                    'Jitter_Abs': float(Jitter_Abs), 'RAP': float(RAP), 'PPQ': float(PPQ), 'DDP': float(DDP),
                    'Shimmer': float(Shimmer), 'Shimmer_dB': float(Shimmer_dB), 'APQ3': float(APQ3), 
                    'APQ5': float(APQ5), 'APQ': float(APQ), 'DDA': float(DDA), 'NHR': float(NHR), 
                    'HNR': float(HNR), 'RPDE': float(RPDE), 'DFA': float(DFA), 'spread1': float(spread1), 
                    'spread2': float(spread2), 'D2': float(D2), 'PPE': float(PPE),
                    'Outcome': 1 if result == 'Yes' else 0 # Convert 'Yes'/'No' to 1/0 for ML training
                }
                append_client_parkinsons_data(prediction_data_for_fl, user_id)
                # --- END NEW ---

                # NEW: Hash test result data before storing in SQLite DB
                hashed_user_id, user_id_salt = hash_data_field(user_id)
                hashed_name, name_salt = hash_data_field(name)
                hashed_date, date_salt = hash_data_field(date)
                hashed_time, time_salt = hash_data_field(time)
                hashed_disease, disease_salt = hash_data_field("Parkinson's")
                hashed_result, result_salt = hash_data_field(result)

                # Generate combined bcrypt hash for record integrity
                combined_hashes = [hashed_user_id, hashed_name, hashed_date, hashed_time, hashed_disease, hashed_result]
                combined_bcrypt_hash = hash_record_integrity(combined_hashes)

                cursor.execute('''INSERT INTO test_results1 (user_id_hash, user_id_salt, name_hash, name_salt, 
                                 date_hash, date_salt, time_hash, time_salt, disease_hash, disease_salt, 
                                 result_hash, result_salt, combined_bcrypt_hash)
                                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''', 
                                 (hashed_user_id, user_id_salt, hashed_name, name_salt, hashed_date, date_salt, 
                                  hashed_time, time_salt, hashed_disease, disease_salt, hashed_result, result_salt, 
                                  combined_bcrypt_hash))
                conn.commit()
                st.success("Record stored in local Database successfully!")

            except ValueError:
                st.error("Please enter valid numerical values for all inputs.")
            except Exception as e:
                st.error(f"Error in prediction: {e}")

        # Show Popup For Patient Information and Report Generation (Parkinson's)
        show_popup_parkinsons = st.checkbox("Click To Enter Patient Details:", key="parkinsons_details_checkbox")
        if show_popup_parkinsons:
            # Initialize session state for patient details if they don't exist
            if "parkinsons_patient_name" not in st.session_state:
                st.session_state["parkinsons_patient_name"] = ""
                st.session_state["parkinsons_patient_id_report"] = ""
                st.session_state["parkinsons_patient_address"] = ""
                st.session_state["parkinsons_patient_contact_number"] = ""
                st.session_state["parkinsons_patient_email"] = ""
                st.session_state["parkinsons_patient_gender"] = ""
                st.session_state["parkinsons_patient_age"] = ""
                st.session_state["parkinsons_doctors_name"] = ""
                st.session_state["parkinsons_show_download"] = False

            patient_name = st.text_input("Patient Name", value=st.session_state["parkinsons_patient_name"], key="input_parkinsons_patient_name")
            patient_id_report = st.text_input("Patient User ID (e.g., 301000 for registered patient)", value=st.session_state["parkinsons_patient_id_report"], key="input_parkinsons_patient_id_report")
            patient_address = st.text_input("Address", value=st.session_state["parkinsons_patient_address"], key="input_parkinsons_patient_address")
            patient_contact_number = st.text_input("Contact Number", value=st.session_state["parkinsons_patient_contact_number"], key="input_parkinsons_patient_contact")
            patient_email = st.text_input("Email", value=st.session_state["parkinsons_patient_email"], key="input_parkinsons_patient_email")
            
            gender_options = ["Male", "Female", "Other"]
            current_gender_index = gender_options.index(st.session_state["parkinsons_patient_gender"]) if st.session_state["parkinsons_patient_gender"] else 0
            patient_gender = st.selectbox("Gender", gender_options, index=current_gender_index, key="input_parkinsons_patient_gender")
            
            patient_age = st.text_input("Age", value=st.session_state["parkinsons_patient_age"], key="input_parkinsons_patient_age")
            doctors_name = st.text_input("Doctor Name", value=st.session_state["parkinsons_doctors_name"], key="input_parkinsons_doctors_name")
            
            if st.button("Submit Patient Details", key="submit_parkinsons_patient_details"):
                if not patient_id_report:
                    st.error("Please enter the Patient User ID for report generation.")
                    st.stop()
                if st.session_state["parkinsons_prediction_result"] is None:
                    st.error("Please run the Parkinson's prediction first before submitting patient details for the report.")
                    st.stop()
                st.session_state["parkinsons_patient_name"] = patient_name
                st.session_state["parkinsons_patient_id_report"] = patient_id_report
                st.session_state["parkinsons_patient_address"] = patient_address
                st.session_state["parkinsons_patient_contact_number"] = patient_contact_number
                st.session_state["parkinsons_patient_email"] = patient_email
                st.session_state["parkinsons_patient_gender"] = patient_gender
                st.session_state["parkinsons_patient_age"] = patient_age
                st.session_state["parkinsons_doctors_name"] = doctors_name
                st.success("Parkinson's Patient Details Submitted!")
                st.session_state["parkinsons_show_download"] = True

            if st.session_state.get("parkinsons_show_download", False) and st.session_state["parkinsons_patient_id_report"]:
                class PDF(FPDF):
                    def header(self):
                        self.set_fill_color(119, 185, 71)
                        self.set_text_color(255, 255, 255)
                        self.set_font("Arial", "B", 18)
                        self.cell(0, 20, "ChainLearn Nexus Lab", ln=True, align='C', fill=True)
                        self.ln(5)

                    def footer(self):
                        self.set_y(-15)
                        self.set_font('Arial', 'I', 8)
                        self.set_text_color(128)
                        self.cell(0, 10, f'Page {self.page_no()}', 0, 0, 'C')

                pdf = PDF()
                pdf.add_page()
                pdf.set_font("Arial", size=12)
                pdf.cell(200, 10, "", ln=True) # Spacer
                pdf.set_text_color(0, 0, 0)
                pdf.set_font("Arial", size=12)

                # Patient and Doctor Details
                pdf.set_font("Arial", size=12)
                pdf.cell(95, 10, f"Patient Name: {st.session_state['parkinsons_patient_name']}", border=1, align='L')
                pdf.cell(95, 10, f"Patient ID: {st.session_state['parkinsons_patient_id_report']}", border=1, align='L')
                pdf.ln()
                pdf.cell(95, 10, f"Address: {st.session_state['parkinsons_patient_address']}", border=1, align='L')
                pdf.cell(95, 10, f"Contact Number: {st.session_state['parkinsons_patient_contact_number']}", border=1, align='L')
                pdf.ln()
                pdf.cell(95, 10, f"Email: {st.session_state['parkinsons_patient_email']}", border=1, align='L')
                pdf.cell(95, 10, f"Gender: {st.session_state['parkinsons_patient_gender']}", border=1, align='L')
                pdf.ln()
                pdf.cell(95, 10, f"Age: {st.session_state['parkinsons_patient_age']}", border=1, align='L')
                pdf.cell(95, 10, f"Doctor's Name: {st.session_state['parkinsons_doctors_name']}", border=1, align='L')
                pdf.ln()
                pdf.cell(95, 10, f"Date: {date}", border=1, align='L')
                pdf.cell(95, 10, f"Time: {time}", border=1, align='L')
                pdf.ln()
                
                parkinsons_result_text = "N/A (Run prediction first)" 
                if st.session_state["parkinsons_prediction_result"] is not None: # Check if result was actually set by a prediction
                    parkinsons_result_text = "Parkinson's Disease" if st.session_state["parkinsons_prediction_result"].strip().lower() == "yes" else "No Parkinson's Disease"
                pdf.set_font("Arial", style='B', size=12)
                pdf.cell(95, 10, f"Parkinson's Result: {parkinsons_result_text}", border=1, align='L')
                pdf.ln()

                pdf.ln(10)
                pdf.set_fill_color(200, 200, 200)
                pdf.cell(95, 10, "Parameter", border=1, fill=True, align='C')
                pdf.cell(95, 10, "Value", border=1, fill=True, align='C')
                pdf.ln()

                data = [
                    ("MDVP:Fo(Hz)", fo), ("MDVP:Fhi(Hz)", fhi), ("MDVP:Flo(Hz)", flo), ("MDVP:Jitter(%)", Jitter_percent),
                    ("MDVP:Jitter(Abs)", Jitter_Abs), ("MDVP:RAP", RAP), ("MDVP:PPQ", PPQ), ("Jitter:DDP", DDP),
                    ("MDVP:Shimmer", Shimmer), ("MDVP:Shimmer(dB)", Shimmer_dB), ("Shimmer:APQ3", APQ3), 
                    ("APQ5", APQ5), ("MDVP:APQ", APQ), ("DDA", DDA), ("NHR", NHR), 
                    ("HNR", HNR), ("RPDE", RPDE), ("DFA", DFA), ("spread1", spread1), 
                    ("spread2", spread2), ("D2", D2), ("PPE", PPE)
                ]
            
                for param, value in data:
                    pdf.cell(95, 10, param, border=1, align='C')
                    pdf.cell(95, 10, str(value), border=1, align='C') # Ensure value is string
                    pdf.ln()

                pdf.ln(10)
                pdf.cell(200, 10, "Special Instruction By Doctor :", ln=True)
                pdf.ln(40)
                pdf.set_font("Courier", size=12)
                pdf.cell(200, 10, f"Approved By: ChainLearn Nexus Lab   Signed By: {name}", ln=True, align='C')
            
                output_dir = r"./Report/Parkinsons_Reports"
                os.makedirs(output_dir, exist_ok=True)
                # NEW PDF NAMING: patient_name_patient_id_disease_report.pdf
                pdf_output = os.path.join(output_dir, f"{st.session_state['parkinsons_patient_name']}_{st.session_state['parkinsons_patient_id_report']}_parkinsons_report.pdf")
                pdf.output(pdf_output)

                with open(pdf_output, "rb") as file:
                    st.download_button(label="Download Report", data=file, file_name=f"{st.session_state['parkinsons_patient_name']}_{st.session_state['parkinsons_patient_id_report']}_parkinsons_report.pdf", mime="application/pdf")


    elif selected == "SQL Records":
        st.title("User Test Records (SQLite)")
        if st.session_state['role'] == "Doctor":
            # Modified SQL query to retrieve all hash-related columns
            cursor.execute('''SELECT 
                                id, user_id_hash, user_id_salt, name_hash, name_salt, 
                                date_hash, date_salt, time_hash, time_salt, disease_hash, disease_salt, 
                                result_hash, result_salt, combined_bcrypt_hash 
                              FROM test_results1 ORDER BY date_hash DESC, time_hash DESC''')
            records = cursor.fetchall()
            if records:
                # Updated DataFrame columns to reflect hashed data
                df_records = pd.DataFrame(records, columns=[
                    "ID", "User ID Hash", "User ID Salt", "Name Hash", "Name Salt", 
                    "Date Hash", "Date Salt", "Time Hash", "Time Salt", "Disease Hash", 
                    "Disease Salt", "Result Hash", "Result Salt", "Combined Bcrypt Hash"
                ])
                st.dataframe(df_records, use_container_width=True) # Increased width here
                st.warning("Note: Data in this table is hashed for security and cannot be reverted to original values. You will see hashes instead of actual data.")
            else:
                st.info("No test records found in the local database.")
        else:
            st.warning("You do not have permission to view this page.")

    elif selected == "About":
        st.title("About ChainLearn Nexus Software")
        
        st.subheader("What is this software?")
        st.write("This software is an AI-powered multi-disease prediction tool designed exclusively for doctors. It helps in diagnosing various diseases such as Parkinson's, Diabetes, and Heart Disease based on patient medical records and advanced machine learning algorithms.")
        
        st.subheader("What can it do?")
        st.write("- Predict multiple diseases based on patient input parameters.")
        st.write("- Generate and store patient reports securely.")
        st.write("- Provide AI-driven insights to assist doctors in decision-making.")
        st.write("- Maintain a decentralized, blockchain-based medical record system.")
        
        st.subheader("Future Goals")
        st.write("- Add more disease prediction capabilities.")
        st.write("- Improve model accuracy with advanced AI techniques.")
        st.write("- Implement real-time monitoring and alert systems.")
        st.write("- Integrate with hospital management systems.")
        
        st.subheader("Frequently Asked Questions (FAQ)")
        
        faqs = {
            "Who can use this software?": "Only licensed doctors and healthcare professionals can use this system.",
            "What diseases does it currently support?": "The software supports predictions for Parkinson's, Diabetes, and Heart Disease, with plans to add more in the future.",
            "How accurate are the predictions?": "The models are trained on medical datasets and optimized for high accuracy, but final decisions should always be made by a doctor.",
            "Is patient data secure?": "Yes, sensitive patient data in the `test_results1` table is hashed using a double-layered mechanism (SHA-256 and bcrypt) for enhanced security and integrity.",
            "Can this software be used for self-diagnosis?": "No, it is strictly for professional medical use by doctors.",
            "Does it support multi-user access?": "Yes, multiple doctors and receptionists can use the platform with proper authentication.",
            "Is there an option to print or download reports?": "Yes, you can generate, download, and print patient reports in PDF format.",
            "Can I integrate this with hospital records?": "Integration with hospital management systems is a future roadmap feature.",
            "What technologies power this software?": "It is built using Python, TensorFlow, Streamlit, and federated learning.",
            "How can I get support or request a new feature?": "You can contact the development team via the official support channel for assistance or feature requests."
        }
        
        for question, answer in faqs.items():
            with st.expander(question):
                st.write(answer)

    elif selected == "Developed By":
        st.title("üë®‚Äçüíª Developed By")
        st.markdown("""
        <style>
            .developer-card {
                background-color: #f8f9fa;
                padding: 15px;
                margin: 10px 0;
                border-radius: 10px;
                box-shadow: 2px 2px 10px rgba(0,0,0,0.1);
            }
            .developer-name {
                font-size: 20px;
                font-weight: bold;
                color: #2c3e50;
            }
        </style>
        """, unsafe_allow_html=True)
        
        st.write("### Meet the Developers of ChainLearn Nexus")
        developers = ["Aniket Ghosh", "Anubhob Dey", "Arkadeep Ghosh", "Kallol Dawn", "Shubhojit Nandy" ]
        for dev in developers:
            st.markdown(f"""
            <div class='developer-card'>
                <p class='developer-name'>{dev}</p>
            </div>
            """, unsafe_allow_html=True)

    elif selected == "Logout":
        st.session_state["logged_in"] = False
        st.session_state["user_id"] = None
        st.session_state["role"] = None
        st.session_state["name"] = None
        st.success("Logged out successfully!")
        st.rerun()

# --- Main App Logic for Receptionist Role ---
elif st.session_state['logged_in'] and st.session_state['role'] == "Receptionist":
    st.write(f"Welcome, **{st.session_state['name']}** (User ID: **{st.session_state['user_id']}**)")
    with st.sidebar:
        selected = option_menu(
            "ChainLearn Nexus",
            [
                "Manage Doctors",
                "Manage Appointments",
                "Logout",
            ],
            icons=["person-fill", "calendar-check", "box-arrow-right"],
            default_index=0,
        )
    
    if selected == "Manage Doctors":
        st.title("Manage Doctor Information")
        with st.form("add_doctor_form"):
            st.subheader("Add New Doctor")
            doc_name = st.text_input("Doctor Name", key="add_doc_name")
            specialization = st.text_input("Specialization (e.g., Ortho, Cardio)", key="add_specialization")
            
            # Generate doctor_id based on specialization
            generated_doc_id = ""
            if specialization and len(specialization) >= 2:
                prefix = specialization[:2].lower()
                cursor.execute(f"SELECT doctor_id FROM doctors WHERE doctor_id LIKE '{prefix}%' ORDER BY doctor_id DESC LIMIT 1")
                last_doc_id = cursor.fetchone()
                if last_doc_id:
                    try:
                        last_num = int(last_doc_id[0][len(prefix):])
                        generated_doc_id = f"{prefix}{last_num + 1}"
                    except ValueError:
                        generated_doc_id = f"{prefix}10100" # Fallback if parsing fails
                else:
                    generated_doc_id = f"{prefix}10100"
            else:
                generated_doc_id = "Enter specialization for ID"

            st.text_input("Doctor ID (Auto-generated)", value=generated_doc_id, disabled=True, key="add_doc_id_display")

            qualifications = st.text_area("Qualifications", key="add_qualifications")
            experience = st.number_input("Experience (Years)", min_value=0, key="add_experience")
            location = st.text_input("Location", key="add_location")
            phone = st.text_input("Phone Number", key="add_phone")
            email = st.text_input("Email", key="add_email")
            chambers = st.text_input("Chambers/Clinic Address", key="add_chambers")
            rating = st.slider("Rating (1-5)", 1, 5, 3, key="add_rating")
            add_doc_button = st.form_submit_button("Add Doctor")
            if add_doc_button:
                if generated_doc_id == "Enter specialization for ID" or len(specialization) < 2:
                    st.error("Please enter a specialization of at least 2 characters to generate Doctor ID.")
                else:
                    try:
                        cursor.execute(
                            "INSERT INTO doctors (doctor_id, name, specialization, qualifications, experience, location, phone, email, chambers, rating) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                            (generated_doc_id, doc_name, specialization, qualifications, experience, location, phone, email, chambers, rating)
                        )
                        conn.commit()
                        st.success(f"Doctor {doc_name} added successfully with ID: {generated_doc_id}!")
                        st.rerun() # Rerun to refresh the list of doctors
                    except sqlite3.IntegrityError:
                        st.error("Generated Doctor ID might already exist or another unique constraint violated. Please try again or check inputs.")
                    except Exception as e:
                        st.error(f"Error adding doctor: {e}")

        st.subheader("Existing Doctors")
        cursor.execute("SELECT * FROM doctors")
        doctors_data = cursor.fetchall()
        if doctors_data:
            df_doctors = pd.DataFrame(doctors_data, columns=["ID", "Doctor ID", "Name", "Specialization", "Qualifications", "Experience", "Location", "Phone", "Email", "Chambers", "Rating"])
            st.dataframe(df_doctors)

            # Update Doctor
            st.subheader("Update Doctor Details")
            doc_options = [f"{doc[2]} - {doc[1]}" for doc in doctors_data] # Format: Name - ID
            selected_doc_for_update = st.selectbox("Select Doctor to Update", [""] + doc_options, key="update_doc_select")
            
            doc_to_update_id = ""
            if selected_doc_for_update:
                doc_to_update_id = selected_doc_for_update.split(" - ")[1] # Extract ID

            if doc_to_update_id:
                cursor.execute("SELECT * FROM doctors WHERE doctor_id = ?", (doc_to_update_id,))
                doc_to_update = cursor.fetchone()
                if doc_to_update:
                    with st.form(key=f"update_doctor_form_{doc_to_update_id}"):
                        st.text_input("Doctor ID", value=doc_to_update[1], disabled=True) # Display ID, but keep disabled
                        new_name = st.text_input("New Name", value=doc_to_update[2], key="update_name")
                        new_specialization = st.text_input("New Specialization", value=doc_to_update[3], key="update_specialization")
                        new_qualifications = st.text_area("New Qualifications", value=doc_to_update[4], key="update_qualifications")
                        new_experience = st.number_input("New Experience (Years)", min_value=0, value=doc_to_update[5], key="update_experience")
                        new_location = st.text_input("New Location", value=doc_to_update[6], key="update_location")
                        new_phone = st.text_input("New Phone Number", value=doc_to_update[7], key="update_phone")
                        new_email = st.text_input("New Email", value=doc_to_update[8], key="update_email")
                        new_chambers = st.text_input("New Chambers/Clinic Address", value=doc_to_update[9], key="update_chambers")
                        new_rating = st.slider("New Rating (1-5)", 1, 5, doc_to_update[10], key="update_rating")
                        update_doc_button = st.form_submit_button("Update Doctor")
                        if update_doc_button:
                            try:
                                cursor.execute(
                                    """UPDATE doctors SET name=?, specialization=?, qualifications=?, experience=?, 
                                    location=?, phone=?, email=?, chambers=?, rating=? WHERE doctor_id=?""",
                                    (new_name, new_specialization, new_qualifications, new_experience,
                                     new_location, new_phone, new_email, new_chambers, new_rating, doc_to_update_id)
                                )
                                conn.commit()
                                st.success(f"Doctor {doc_to_update_id} updated successfully!")
                                st.rerun()
                            except Exception as e:
                                st.error(f"Error updating doctor: {e}")
                else:
                    st.warning("Doctor ID not found.")

            # Delete Doctor
            st.subheader("Delete Doctor")
            selected_doc_for_delete = st.selectbox("Select Doctor to Delete", [""] + doc_options, key="delete_doc_select")
            doc_to_delete_id = ""
            if selected_doc_for_delete:
                doc_to_delete_id = selected_doc_for_delete.split(" - ")[1]

            if st.button("Delete Doctor"):
                if doc_to_delete_id:
                    try:
                        cursor.execute("DELETE FROM doctors WHERE doctor_id = ?", (doc_to_delete_id,))
                        conn.commit()
                        if cursor.rowcount > 0:
                            st.success(f"Doctor {doc_to_delete_id} deleted successfully!")
                            st.rerun()
                        else:
                            st.warning("Doctor ID not found.")
                    except Exception as e:
                        st.error(f"Error deleting doctor: {e}")
                else:
                    st.warning("Please select a doctor to delete.")
        else:
            st.info("No doctors registered yet.")

    elif selected == "Manage Appointments":
        st.title("Manage Appointments")

        # Fetch doctors for the selectbox
        cursor.execute("SELECT doctor_id, name FROM doctors")
        doctors_for_select = cursor.fetchall()
        doctor_options = [""] + [f"{doc[1]} - {doc[0]}" for doc in doctors_for_select] # Format: Name - ID

        # --- Schedule New Appointment Section ---
        st.subheader("Schedule New Appointment")
        # Define mode outside the form to allow immediate reactivity
        mode_add = st.selectbox("Mode", ["Online", "Offline"], key="add_appt_mode_select")
        
        # Conditional QR code display for Online mode (immediate)
        if mode_add == "Online":
            col_qr1, col_qr2, col_qr3 = st.columns([2, 3, 2]) # Adjust ratios as needed for centering
            with col_qr2:
                st.image(QR_CODE_PLACEHOLDER_URL, caption="Scan this QR code for online payment.", width=350)
            st.info("Note: In a real application, this QR code would be dynamically generated for the specific payment.")
        
        with st.form("add_appointment_form"):
            patient_name = st.text_input("Patient Name", key="add_patient_name_appt")

            # MODIFIED: Patient ID is now manually entered by receptionist, should be Patient's User ID if registered
            patient_id_for_appt = st.text_input("Patient User ID (e.g., 301000 for registered patient)", key="add_patient_id_appt")
            st.info("For registered patients, please enter their User ID here. For new patients, generate a unique ID (e.g., initials + 4 digits).")
            
            selected_doctor_option = st.selectbox("Select Doctor", options=doctor_options, key="add_appt_doctor_select")
            doctor_id_for_appt = ""
            if selected_doctor_option:
                doctor_id_for_appt = selected_doctor_option.split(" - ")[1] # Extract ID

            appointment_date = st.date_input("Appointment Date", key="add_appt_date")
            appointment_time = st.text_input("Appointment Time (e.g., 10:00 AM)", key="add_appt_time")
            reason = st.text_area("Reason for Appointment", key="add_appt_reason")
            phone = st.text_input("Patient Phone Number", key="add_appt_phone")
            email = st.text_input("Patient Email", key="add_appt_email")
            location = st.text_input("Appointment Location", key="add_appt_location")
            status = st.selectbox("Status", ["Scheduled", "Completed", "Cancelled"], key="add_appt_status")
            payment_details = st.text_input("Payment Details", key="add_appt_payment")
            
            # Pass the mode_add value into the form submission logic
            # The mode_add selectbox is defined outside the form for immediate reactivity
            
            instructions = st.text_area("Instructions for Patient", key="add_appt_instructions")
            add_appt_button = st.form_submit_button("Schedule Appointment")
            if add_appt_button:
                if not patient_id_for_appt:
                    st.error("Please enter a Patient User ID.")
                elif not doctor_id_for_appt:
                    st.error("Please select a doctor for the appointment.")
                else:
                    try:
                        cursor.execute(
                            """INSERT INTO appointments (patient_id, patient_name, doctor_id, appointment_date, 
                            appointment_time, reason, phone, email, location, status, payment_details, mode, instructions) 
                            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                            (patient_id_for_appt, patient_name, doctor_id_for_appt, str(appointment_date), appointment_time, reason, 
                             phone, email, location, status, payment_details, mode_add, instructions) # Use mode_add here
                        )
                        conn.commit()
                        st.success(f"Appointment for Patient {patient_name} (ID: {patient_id_for_appt}) scheduled successfully!")
                        st.rerun()
                    except sqlite3.IntegrityError:
                        st.error("Patient ID already has an appointment. Please use a unique ID or update existing.")
                    except Exception as e:
                        st.error(f"Error scheduling appointment: {e}")
        
        st.subheader("Upcoming Appointments")
        cursor.execute("SELECT * FROM appointments ORDER BY appointment_date ASC, appointment_time ASC")
        appointments_data = cursor.fetchall()
        if appointments_data:
            df_appointments = pd.DataFrame(appointments_data, columns=["ID", "Patient ID", "Patient Name", "Doctor ID", "Date", "Time", "Reason", "Phone", "Email", "Location", "Status", "Payment", "Mode", "Instructions"])
            st.dataframe(df_appointments)

            # Update Appointment Section
            st.subheader("Update Appointment Details")
            appt_options = [f"{appt[2]} - {appt[1]}" for appt in appointments_data] # Format: Patient Name - Patient ID
            selected_appt_for_update = st.selectbox("Select Appointment to Update", [""] + appt_options, key="update_appt_select")
            
            appt_to_update_id = ""
            if selected_appt_for_update:
                appt_to_update_id = selected_appt_for_update.split(" - ")[1] # Extract Patient ID

            if appt_to_update_id:
                cursor.execute("SELECT * FROM appointments WHERE patient_id = ?", (appt_to_update_id,))
                appt_to_update = cursor.fetchone()
                if appt_to_update:
                    # Define new_mode outside the form for immediate reactivity
                    new_mode = st.selectbox("New Mode", ["Online", "Offline"], index=["Online", "Offline"].index(appt_to_update[12]), key="update_appt_mode_select")
                    
                    # Conditional QR code display for Online mode in update form (immediate)
                    if new_mode == "Online":
                        st.image(QR_CODE_PLACEHOLDER_URL, caption="Scan this QR code for online payment.", width=150)
                        st.info("Note: In a real application, this QR code would be dynamically generated for the specific payment.")
                    
                    with st.form(key=f"update_appt_form_{appt_to_update_id}"):
                        st.text_input("Patient ID", value=appt_to_update[1], disabled=True) # Display Patient ID, disabled
                        new_patient_name = st.text_input("New Patient Name", value=appt_to_update[2], key="update_patient_name")
                        
                        # Find current doctor's index for selectbox
                        current_doctor_id = appt_to_update[3]
                        current_doctor_option = ""
                        for option in doctor_options:
                            if current_doctor_id in option:
                                current_doctor_option = option
                                break
                        new_selected_doctor_option = st.selectbox("New Doctor", options=doctor_options, index=doctor_options.index(current_doctor_option) if current_doctor_option else 0, key="update_appt_doctor_select")
                        new_doctor_id = ""
                        if new_selected_doctor_option:
                            new_doctor_id = new_selected_doctor_option.split(" - ")[1]

                        new_appointment_date = st.date_input("New Appointment Date", value=datetime.datetime.strptime(appt_to_update[4], "%Y-%m-%d").date(), key="update_appt_date")
                        new_appointment_time = st.text_input("New Appointment Time", value=appt_to_update[5], key="update_appt_time")
                        new_reason = st.text_area("New Reason", value=appt_to_update[6], key="update_appt_reason")
                        new_phone = st.text_input("New Patient Phone Number", value=appt_to_update[7], key="update_appt_phone")
                        new_email = st.text_input("New Patient Email", value=appt_to_update[8], key="update_appt_email")
                        new_location = st.text_input("New Appointment Location", value=appt_to_update[9], key="update_appt_location")
                        new_status = st.selectbox("New Status", ["Scheduled", "Completed", "Cancelled"], index=["Scheduled", "Completed", "Cancelled"].index(appt_to_update[10]), key="update_appt_status")
                        new_payment_details = st.text_input("New Payment Details", value=appt_to_update[11], key="update_appt_payment")
                        
                        # Pass the new_mode value into the form submission logic
                        # The new_mode selectbox is defined outside the form for immediate reactivity

                        new_instructions = st.text_area("New Instructions", value=appt_to_update[13], key="update_appt_instructions")
                        update_appt_button = st.form_submit_button("Update Appointment")
                        if update_appt_button:
                            if not new_doctor_id:
                                st.error("Please select a doctor for the appointment.")
                            else:
                                try:
                                    cursor.execute(
                                        """UPDATE appointments SET patient_name=?, doctor_id=?, appointment_date=?, 
                                        appointment_time=?, reason=?, phone=?, email=?, location=?, status=?, 
                                        payment_details=?, mode=?, instructions=? WHERE patient_id=?""",
                                        (new_patient_name, new_doctor_id, str(new_appointment_date), new_appointment_time, 
                                         new_reason, new_phone, new_email, new_location, new_status, new_payment_details, 
                                         new_mode, new_instructions, appt_to_update_id) # Use new_mode here
                                    )
                                    conn.commit()
                                    st.success(f"Appointment for Patient {appt_to_update_id} updated successfully!")
                                    st.rerun()
                                except Exception as e:
                                    st.error(f"Error updating appointment: {e}")
                else:
                    st.warning("Patient ID not found for appointment.")

            # Delete Appointment
            st.subheader("Delete Appointment")
            selected_appt_for_delete = st.selectbox("Select Appointment to Delete", [""] + appt_options, key="delete_appt_select")
            appt_to_delete_id = ""
            if selected_appt_for_delete:
                appt_to_delete_id = selected_appt_for_delete.split(" - ")[1]

            if st.button("Delete Appointment"):
                if appt_to_delete_id:
                    try:
                        cursor.execute("DELETE FROM appointments WHERE patient_id = ?", (appt_to_delete_id,))
                        conn.commit()
                        if cursor.rowcount > 0:
                            st.success(f"Appointment for Patient {appt_to_delete_id} deleted successfully!")
                            st.rerun()
                        else:
                            st.warning("Patient ID not found for appointment.")
                    except Exception as e:
                        st.error(f"Error deleting appointment: {e}")
                else:
                    st.warning("Please select an appointment to delete.")
        else:
            st.info("No appointments scheduled yet.")

    elif selected == "Logout":
        st.session_state["logged_in"] = False
        st.session_state["user_id"] = None
        st.session_state["role"] = None
        st.session_state["name"] = None
        st.success("Logged out successfully!")
        st.rerun()

# --- Main App Logic for Patient Role ---
elif st.session_state['logged_in'] and st.session_state['role'] == "Patient":
    st.write(f"Welcome, **{st.session_state['name']}** (User ID: **{st.session_state['user_id']}**)")
    
    with st.sidebar:
        selected = option_menu(
            "ChainLearn Nexus",
            [
                "My Reports",
                "About",
                "Developed By",
                "Logout",
            ],
            icons=["file-earmark-text", "link", "bi-info-circle", "box-arrow-right"],
            default_index=0,
        )

    if selected == "My Reports":
        st.title("My Medical Reports")
        patient_user_id = st.session_state['user_id']
        report_found = False

        st.subheader(f"Reports for User ID: {patient_user_id}")

        report_dirs = {
            "Diabetes": "./Report/Diabetes_Reports",
            "Heart Disease": "./Report/Heart_Reports",
            "Parkinson's": "./Report/Parkinsons_Reports"
        }

        for disease_type, path in report_dirs.items():
            st.markdown(f"### {disease_type} Reports")
            if os.path.exists(path):
                # List files and filter for PDFs containing the patient's user ID
                found_files = [f for f in os.listdir(path) if f.endswith(".pdf") and patient_user_id in f]
                
                if found_files:
                    report_found = True
                    for pdf_file in found_files:
                        pdf_path = os.path.join(path, pdf_file)
                        with open(pdf_path, "rb") as file:
                            st.download_button(
                                label=f"Download {pdf_file}",
                                data=file,
                                file_name=pdf_file,
                                mime="application/pdf",
                                key=f"download_{disease_type}_{pdf_file}"
                            )
                else:
                    st.info(f"No {disease_type} reports found for your User ID yet.")
            else:
                st.info(f"Report directory not found: {path}")

        if not report_found:
            st.warning("No medical reports found for your User ID across all categories.")
            st.info("Reports are generated by the doctor/receptionist after a test. Please ensure your User ID was used when generating the report.")

    elif selected == "About":
        st.title("About ChainLearn Nexus Software")
        
        st.subheader("What is this software?")
        st.write("This software is an AI-powered multi-disease prediction tool designed exclusively for doctors. It helps in diagnosing various diseases such as Parkinson's, Diabetes, and Heart Disease based on patient medical records and advanced machine learning algorithms.")
        
        st.subheader("What can it do?")
        st.write("- Predict multiple diseases based on patient input parameters.")
        st.write("- Generate and store patient reports securely.")
        st.write("- Provide AI-driven insights to assist doctors in decision-making.")
        st.write("- Maintain a decentralized, blockchain-based medical record system.")
        
        st.subheader("Future Goals")
        st.write("- Add more disease prediction capabilities.")
        st.write("- Improve model accuracy with advanced AI techniques.")
        st.write("- Implement real-time monitoring and alert systems.")
        st.write("- Integrate with hospital management systems.")
        
        st.subheader("Frequently Asked Questions (FAQ)")
        
        faqs = {
            "Who can use this software?": "Only licensed doctors and healthcare professionals can use this system, along with registered patients to view their reports.",
            "What diseases does it currently support?": "The software supports predictions for Parkinson's, Diabetes, and Heart Disease, with plans to add more in the future.",
            "How accurate are the predictions?": "The models are trained on medical datasets and optimized for high accuracy, but final decisions should always be made by a doctor.",
            "Is patient data secure?": "Yes, sensitive patient data in the `test_results1` table is hashed using a double-layered mechanism (SHA-256 and bcrypt) for enhanced security and integrity.",
            "Can this software be used for self-diagnosis?": "No, it is strictly for professional medical use by doctors.",
            "Does it support multi-user access?": "Yes, multiple doctors, receptionists, and patients can use the platform with proper authentication.",
            "Is there an option to print or download reports?": "Yes, you can generate, download, and print patient reports in PDF format.",
            "Can I integrate this with hospital records?": "Integration with hospital management systems is a future roadmap feature.",
            "What technologies power this software?": "It is built using Python, TensorFlow, Streamlit, and federated learning.",
            "How can I get support or request a new feature?": "You can contact the development team via the official support channel for assistance or feature requests."
        }
        
        for question, answer in faqs.items():
            with st.expander(question):
                st.write(answer)

    elif selected == "Developed By":
        st.title("üë®‚Äçüíª Developed By")
        st.markdown("""
        <style>
            .developer-card {
                background-color: #f8f9fa;
                padding: 15px;
                margin: 10px 0;
                border-radius: 10px;
                box-shadow: 2px 2px 10px rgba(0,0,0,0.1);
            }
            .developer-name {
                font-size: 20px;
                font-weight: bold;
                color: #2c3e50;
            }
        </style>
        """, unsafe_allow_html=True)
        
        st.write("### Meet the Developers of ChainLearn Nexus")
        developers = ["Aniket Ghosh", "Anubhob Dey", "Arkadeep Ghosh", "Kallol Dawn", "Shubhojit Nandy"]
        for dev in developers:
            st.markdown(f"""
            <div class='developer-card'>
                <p class='developer-name'>{dev}</p>
            </div>
            """, unsafe_allow_html=True)

    elif selected == "Logout":
        st.session_state["logged_in"] = False
        st.session_state["user_id"] = None
        st.session_state["role"] = None
        st.session_state["name"] = None
        st.success("Logged out successfully!")
        st.rerun()

# --- Placeholder for non-logged in state ---
else:
    # This block handles what happens if st.session_state["logged_in"] is False
    # The authentication logic at the top of the script will be displayed.
    pass # No additional code needed here as the login/register forms are already handled
